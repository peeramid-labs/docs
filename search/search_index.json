{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started # Project Overview # You are visiting Peeramid Labs documentation portal. This portal is designed to help you get started with meritocratic autonomous organizations (MAOs) and its components. What is a MAO? # Meritocratic Autonomous Organizations (MAOs) are a new form of decentralized organization that is designed to be more efficient, transparent, and fair than traditional organizations. MAOs are built on blockchain technology, which allows them to operate without a central authority, similarly to DAOs . However, MAOs are different from DAOs in that they are designed to be meritocratic, meaning that decisions are made based on the merit of the participants rather than on their pure wealth or power within the organization. Measuring competences # Autonomously measuring merit is a complex task, and it is done trough a Autonomous Competence Identification Protocol . In a nutshell, it is a continuous process of proposing and voting in semi-anonymous way which allows to measure the competence of the participants relative to their group corresponding intention. By adding a participation time constant, participation cost and a tokenized ranking ladder, it is possible to create a system that will lift the most competent participants to the top of the ladder while exponentially more complex for a sybil group to attack the system.","title":"Getting started"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#project-overview","text":"You are visiting Peeramid Labs documentation portal. This portal is designed to help you get started with meritocratic autonomous organizations (MAOs) and its components.","title":"Project Overview"},{"location":"#what-is-a-mao","text":"Meritocratic Autonomous Organizations (MAOs) are a new form of decentralized organization that is designed to be more efficient, transparent, and fair than traditional organizations. MAOs are built on blockchain technology, which allows them to operate without a central authority, similarly to DAOs . However, MAOs are different from DAOs in that they are designed to be meritocratic, meaning that decisions are made based on the merit of the participants rather than on their pure wealth or power within the organization.","title":"What is a MAO?"},{"location":"#measuring-competences","text":"Autonomously measuring merit is a complex task, and it is done trough a Autonomous Competence Identification Protocol . In a nutshell, it is a continuous process of proposing and voting in semi-anonymous way which allows to measure the competence of the participants relative to their group corresponding intention. By adding a participation time constant, participation cost and a tokenized ranking ladder, it is possible to create a system that will lift the most competent participants to the top of the ladder while exponentially more complex for a sybil group to attack the system.","title":"Measuring competences"},{"location":"governance/","text":"Meritocratic Autonomous Organizations # Meritocratic Autonomous Organizations (MAOs) are a new form of decentralized organization that is designed to be more efficient, transparent, and fair than traditional organizations. MAOs are built on blockchain technology, which allows them to operate without a central authority, similarly to DAOs . However, MAOs are different from DAOs in that they are designed to be meritocratic, meaning that decisions are made based on the merit of the participants rather than on their wealth or power within the organization. Autonomously measuring merit is a complex task, and it is done trough a Autonomous Competence Identification Protocol . Why MAOs? # The traditional DAOs are often criticized for being plutocratic, meaning that decisions are made based on the amount of tokens that a participant holds. This can lead to situations where a small group of wealthy participants can control the organization and make decisions that are not in the best interest of the community. It's been analyzed in multiple research by now that the biggest DAOs out there are not able to make decisions in a timely manner, and that they are often stuck in a deadlock. This is because the quorum is set too high, and because the governance tokens are not distributed in a fair way. Alternatively, setting quorum threshold too low leads to governance quorum attacks and hence to a loss of value of the organization. MAOs are designed to address these issues by using a meritocratic system to distribute governance tokens. This means that decisions are made based on the merit of the participants, rather than on the amount of tokens that they hold. This ensures that decisions are made in the best interest of the community, and that the organization is able to adapt to changing circumstances in a timely manner. MAO structure # In a nutshell, a MAO is just a DAO smart account that is governed by a token that is minted by a competence identification protocol. Such competence identification protocol may be thought of as \"tournament\" that challenges participants to prove their competence in a specific area. The tournament itself can be pretty much anything, as long as it is able to fulfill basic requirements of the protocol. Such are: minimal participation time, and exponential sybil attack resistance. The produced asset is representation of the competence, yet it is not just ready for use in voting. This is used to ensure that exiting ranking ladder is important event for a participant, which designates his role change from a participant to a decision maker. Participant vs Decision Maker # In a MAO, there are two types of participants: participants and decision makers. Participants are those who compete in the competence identification games and earn rank tokens based on their performance. This mechanism allows other organizations to use rank tokens as merit-specific service utility. For example, a third-party DAO may purchase out the competence tokens from participants to use them as reward for performing merit-specific services for that organization. Alternatively they might require participants to stake their tokens in some mission critical service provided by participants to a third party. Decision makers are those who hold governance tokens and are able to vote on proposals and participate in the governance of the MAO. Decision makers obtain governance tokens by exchanging rank tokens for them. This ensures that the governance of the MAO is based on the merit of the participants, rather than on the amount of tokens that they bought during an ICO. By exchanging their rank tokens in to governance power, participants are able to take part in the governance of the MAO and to influence its decisions, this also means their rank gets reset, subjecting their governance power to inflation which acts as incentive for being active in governance. Progressive decentralization # As decision makers eventually lose the quorum their group might have, they are risking losing any assets that they have in the organization. While this is a good incentive for them to stay active in the governance, and prevents the organization from being stuck in a deadlock, its also a risk. In order to prevent this, a MAO can be decentralized further by creating a sub-organization that is derived from the parent organization. This creates a situation where there can be multiple sub-organizations that are all derived from the same parent organization, but that have different governance tokens and different quorums. In order to ensure that the parent organization stays in partial control over the sub-organization assets, the sub-organization is connected to the parent organization via a multi-sig wallet. In the diagram below, you can see one parent organization and two sub-organizations that are derived from it. While each organization is able to make decisions independently, the parent organization is able to stay in partial control over the sub-organizations simply by fact that minting sub-organization governance tokens requires parent governance token as an input. The multi-sig wallet is used to ensure that the parent organization is able to prevent any assets from being lost in the sub-organization. Any transaction from such a multi-signature wallet would require all governing bodies to agree on it. This design ensures parent organization may design the multi-sig wallet in a way that it is able to prevent any assets from being lost in the sub-organization, while still allowing the sub-organization to make decisions independently and promptly.","title":"Meritocratic Autonomous Organizations"},{"location":"governance/#meritocratic-autonomous-organizations","text":"Meritocratic Autonomous Organizations (MAOs) are a new form of decentralized organization that is designed to be more efficient, transparent, and fair than traditional organizations. MAOs are built on blockchain technology, which allows them to operate without a central authority, similarly to DAOs . However, MAOs are different from DAOs in that they are designed to be meritocratic, meaning that decisions are made based on the merit of the participants rather than on their wealth or power within the organization. Autonomously measuring merit is a complex task, and it is done trough a Autonomous Competence Identification Protocol .","title":"Meritocratic Autonomous Organizations"},{"location":"governance/#why-maos","text":"The traditional DAOs are often criticized for being plutocratic, meaning that decisions are made based on the amount of tokens that a participant holds. This can lead to situations where a small group of wealthy participants can control the organization and make decisions that are not in the best interest of the community. It's been analyzed in multiple research by now that the biggest DAOs out there are not able to make decisions in a timely manner, and that they are often stuck in a deadlock. This is because the quorum is set too high, and because the governance tokens are not distributed in a fair way. Alternatively, setting quorum threshold too low leads to governance quorum attacks and hence to a loss of value of the organization. MAOs are designed to address these issues by using a meritocratic system to distribute governance tokens. This means that decisions are made based on the merit of the participants, rather than on the amount of tokens that they hold. This ensures that decisions are made in the best interest of the community, and that the organization is able to adapt to changing circumstances in a timely manner.","title":"Why MAOs?"},{"location":"governance/#mao-structure","text":"In a nutshell, a MAO is just a DAO smart account that is governed by a token that is minted by a competence identification protocol. Such competence identification protocol may be thought of as \"tournament\" that challenges participants to prove their competence in a specific area. The tournament itself can be pretty much anything, as long as it is able to fulfill basic requirements of the protocol. Such are: minimal participation time, and exponential sybil attack resistance. The produced asset is representation of the competence, yet it is not just ready for use in voting. This is used to ensure that exiting ranking ladder is important event for a participant, which designates his role change from a participant to a decision maker.","title":"MAO structure"},{"location":"governance/#participant-vs-decision-maker","text":"In a MAO, there are two types of participants: participants and decision makers. Participants are those who compete in the competence identification games and earn rank tokens based on their performance. This mechanism allows other organizations to use rank tokens as merit-specific service utility. For example, a third-party DAO may purchase out the competence tokens from participants to use them as reward for performing merit-specific services for that organization. Alternatively they might require participants to stake their tokens in some mission critical service provided by participants to a third party. Decision makers are those who hold governance tokens and are able to vote on proposals and participate in the governance of the MAO. Decision makers obtain governance tokens by exchanging rank tokens for them. This ensures that the governance of the MAO is based on the merit of the participants, rather than on the amount of tokens that they bought during an ICO. By exchanging their rank tokens in to governance power, participants are able to take part in the governance of the MAO and to influence its decisions, this also means their rank gets reset, subjecting their governance power to inflation which acts as incentive for being active in governance.","title":"Participant vs Decision Maker"},{"location":"governance/#progressive-decentralization","text":"As decision makers eventually lose the quorum their group might have, they are risking losing any assets that they have in the organization. While this is a good incentive for them to stay active in the governance, and prevents the organization from being stuck in a deadlock, its also a risk. In order to prevent this, a MAO can be decentralized further by creating a sub-organization that is derived from the parent organization. This creates a situation where there can be multiple sub-organizations that are all derived from the same parent organization, but that have different governance tokens and different quorums. In order to ensure that the parent organization stays in partial control over the sub-organization assets, the sub-organization is connected to the parent organization via a multi-sig wallet. In the diagram below, you can see one parent organization and two sub-organizations that are derived from it. While each organization is able to make decisions independently, the parent organization is able to stay in partial control over the sub-organizations simply by fact that minting sub-organization governance tokens requires parent governance token as an input. The multi-sig wallet is used to ensure that the parent organization is able to prevent any assets from being lost in the sub-organization. Any transaction from such a multi-signature wallet would require all governing bodies to agree on it. This design ensures parent organization may design the multi-sig wallet in a way that it is able to prevent any assets from being lost in the sub-organization, while still allowing the sub-organization to make decisions independently and promptly.","title":"Progressive decentralization"},{"location":"tokens/","text":"Tokenomics # In order to maintain globally interoperable meritocratic system, that can be used by any organization, we have defined a set of tokens that provide a base for the system. There is one main token that is used as common denominator for the system, and that is RKFY token. By having this, we may say that the system forms a network of Organizations that all are using same financial basis and hence are interoperable. Token types # RKFY # RKFY is a utility token that allows to instantiate a new organization on the Rankify platform. It has only use to participate in the competence identification games that are deployed from the shared, trusted factory source code and hence provisions inter organization trust. Rankify token is ERC20 token, it will be freely available on the market and hence will ensure that the system is decentralized and is an open economy, anyone can participate in. Rank Token # Rank NFT is a semi fungible token that represents a competence. It is implemented as ERC1155 standard. It acts as a proof of competence that may be used in various scenarios as NFT itself, where token id represents bearers rank (competence) of the bearer. Value of this token is determined by the ranking instance that has issued it, in most general case it's value is approximately equal to the value of the RKFY token a sybil attack would cost which in current implementation is exponential of the token id ( rank ). Note There can exist multiple Rank Tokens for a different causes, that are defined by merit specifications given by the creator. Note Smart contract architecture provisions that there might be additional tokens used for the baseline of the system, in parallel to the RKFY token. These tokens are merit dimension specific and can be exchanged for a governance token in underlying DAO. The exchange mechanism is provided by the MAO factory and is unidirectional, reverse exchange is free-market based. Governance tokens # Governance token is a token that represents a voting power in the DAO. It is implemented as ERC20 standard with voting extensions. It is used to vote on proposals and to participate in the governance of the DAO. Note You can think of this as airdrop replacer. \"Proof of merit \", represented as Rank Token is used to mint governance tokens. Note By the design, governance tokens are always a subject of inflation, as ability to mint those is only limited by the amount of RKFY token that is available. This implies that achieving quorum is a matter of time, and that the DAO is always able to make decisions. This is a design feature that is intended to make the DAOs more efficient and to prevent them from being stuck in a deadlock. Derivate governance tokens # Continuous inflation combined with unidirectional exchange mechanism creates everlasting risk of loss of quorum for those currently holding it within a merit-specific DAO. To prevent this, a derivate MAO can be created on top of the existing one by using current governance token as baseline instead of RKFY . This creates a situation where there can be multiple sub-organizations that are all derived from the same parent organization, but that have different governance tokens and different quorums. This is simple, yet powerful feature that allows to ensure that quorum holders are always able to prevent fund loss or lockups in case of hyperinflation of the governance token. Note We provision a mechanism which will allow parent organization to stay in partial control over the sub-organization assets, hence ensuring there is no parent organization value loss in process of progressively decentralizing the organization. Note This is a powerful feature that allows to create a hierarchy of organizations that are all interoperable and that can be used to create complex governance structures that are able to adapt to the changing environment, and take more granular roles.","title":"Tokenomics"},{"location":"tokens/#tokenomics","text":"In order to maintain globally interoperable meritocratic system, that can be used by any organization, we have defined a set of tokens that provide a base for the system. There is one main token that is used as common denominator for the system, and that is RKFY token. By having this, we may say that the system forms a network of Organizations that all are using same financial basis and hence are interoperable.","title":"Tokenomics"},{"location":"tokens/#token-types","text":"","title":"Token types"},{"location":"tokens/#rkfy","text":"RKFY is a utility token that allows to instantiate a new organization on the Rankify platform. It has only use to participate in the competence identification games that are deployed from the shared, trusted factory source code and hence provisions inter organization trust. Rankify token is ERC20 token, it will be freely available on the market and hence will ensure that the system is decentralized and is an open economy, anyone can participate in.","title":"RKFY"},{"location":"tokens/#rank-token","text":"Rank NFT is a semi fungible token that represents a competence. It is implemented as ERC1155 standard. It acts as a proof of competence that may be used in various scenarios as NFT itself, where token id represents bearers rank (competence) of the bearer. Value of this token is determined by the ranking instance that has issued it, in most general case it's value is approximately equal to the value of the RKFY token a sybil attack would cost which in current implementation is exponential of the token id ( rank ). Note There can exist multiple Rank Tokens for a different causes, that are defined by merit specifications given by the creator. Note Smart contract architecture provisions that there might be additional tokens used for the baseline of the system, in parallel to the RKFY token. These tokens are merit dimension specific and can be exchanged for a governance token in underlying DAO. The exchange mechanism is provided by the MAO factory and is unidirectional, reverse exchange is free-market based.","title":"Rank Token"},{"location":"tokens/#governance-tokens","text":"Governance token is a token that represents a voting power in the DAO. It is implemented as ERC20 standard with voting extensions. It is used to vote on proposals and to participate in the governance of the DAO. Note You can think of this as airdrop replacer. \"Proof of merit \", represented as Rank Token is used to mint governance tokens. Note By the design, governance tokens are always a subject of inflation, as ability to mint those is only limited by the amount of RKFY token that is available. This implies that achieving quorum is a matter of time, and that the DAO is always able to make decisions. This is a design feature that is intended to make the DAOs more efficient and to prevent them from being stuck in a deadlock.","title":"Governance tokens"},{"location":"tokens/#derivate-governance-tokens","text":"Continuous inflation combined with unidirectional exchange mechanism creates everlasting risk of loss of quorum for those currently holding it within a merit-specific DAO. To prevent this, a derivate MAO can be created on top of the existing one by using current governance token as baseline instead of RKFY . This creates a situation where there can be multiple sub-organizations that are all derived from the same parent organization, but that have different governance tokens and different quorums. This is simple, yet powerful feature that allows to ensure that quorum holders are always able to prevent fund loss or lockups in case of hyperinflation of the governance token. Note We provision a mechanism which will allow parent organization to stay in partial control over the sub-organization assets, hence ensuring there is no parent organization value loss in process of progressively decentralizing the organization. Note This is a powerful feature that allows to create a hierarchy of organizations that are all interoperable and that can be used to create complex governance structures that are able to adapt to the changing environment, and take more granular roles.","title":"Derivate governance tokens"},{"location":"Ethereum%20Distribution%20System/IDistribution/","text":"IDistribution # Interface for distribution-related functionalities. It can get sources and produce a new instances out from them. It also provides metadata about the distribution. Notice It is highly recommended to keep implementation stateless, and use immutable variables for any state. This allows your code to be referred in distributor and respositories via ERC7744. It's also easier to reason about, and more gas efficient. Distributed # Emitted when a distribution occurs. event Distributed(address distributor, address[] instances) Input Type Description distributor address The address of the entity that performed the distribution. instances address[] An array of addresses that were produced. instantiate # Instantiates a new instance with the given parameters. function instantiate(bytes data) external returns (address[] instances, bytes32 distributionName, uint256 distributionVersion) Input Type Description data bytes The data to be used for instantiation. Output instances address[] An array of addresses that were produced. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. Warning It MUST emit Distributed event. get # Retrieves the current distribution sources. function get() external view returns (address[] sources, bytes32 distributionName, uint256 distributionVersion) Output Type Description sources address[] An array of addresses that are used for instantiation. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. getMetadata # function getMetadata() external view returns (string)","title":"IDistribution"},{"location":"Ethereum%20Distribution%20System/IDistribution/#idistribution","text":"Interface for distribution-related functionalities. It can get sources and produce a new instances out from them. It also provides metadata about the distribution. Notice It is highly recommended to keep implementation stateless, and use immutable variables for any state. This allows your code to be referred in distributor and respositories via ERC7744. It's also easier to reason about, and more gas efficient.","title":"IDistribution"},{"location":"Ethereum%20Distribution%20System/IDistribution/#distributed","text":"Emitted when a distribution occurs. event Distributed(address distributor, address[] instances) Input Type Description distributor address The address of the entity that performed the distribution. instances address[] An array of addresses that were produced.","title":"Distributed"},{"location":"Ethereum%20Distribution%20System/IDistribution/#instantiate","text":"Instantiates a new instance with the given parameters. function instantiate(bytes data) external returns (address[] instances, bytes32 distributionName, uint256 distributionVersion) Input Type Description data bytes The data to be used for instantiation. Output instances address[] An array of addresses that were produced. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. Warning It MUST emit Distributed event.","title":"instantiate"},{"location":"Ethereum%20Distribution%20System/IDistribution/#get","text":"Retrieves the current distribution sources. function get() external view returns (address[] sources, bytes32 distributionName, uint256 distributionVersion) Output Type Description sources address[] An array of addresses that are used for instantiation. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution.","title":"get"},{"location":"Ethereum%20Distribution%20System/IDistribution/#getmetadata","text":"function getMetadata() external view returns (string)","title":"getMetadata"},{"location":"Ethereum%20Distribution%20System/IDistributor/","text":"IDistributor Interface # Defines the standard functions for a distributor contract. Notice If you want to use IRepository for versioned distributions, use IVersionDistributor interface. DistributionNotFound # Error indicating that the distribution with the specified ID was not found. error DistributionNotFound(bytes32 id) Input Type Description id bytes32 The unique identifier of the distribution that was not found. DistributionExists # Error indicating that a distribution with the specified ID already exists. error DistributionExists(bytes32 id) Input Type Description id bytes32 The unique identifier of the distribution that already exists. InitializerNotFound # Error indicating that the initializer for the distribution was not found. error InitializerNotFound(bytes32 id) Input Type Description id bytes32 The unique identifier of the distribution that was not found. InvalidInstance # Error indicating that the instance is invalid. error InvalidInstance(address instance) Input Type Description instance address The address of the instance that is considered invalid. Instantiated # Event emitted when a new distribution is instantiated. event Instantiated(bytes32 distributionId, uint256 instanceId, bytes argsHash, address[] instances) Input Type Description distributionId bytes32 The unique identifier of the distribution. instanceId uint256 The unique identifier of the instance. argsHash bytes The hash of the arguments used to instantiate the distribution. instances address[] The addresses of the instances that were created. Notice It MUST emit when IDistributor#instantiate is called. DistributionRemoved # Event emitted when a distribution is removed. event DistributionRemoved(bytes32 id) Input Type Description id bytes32 The unique identifier of the distribution that was removed. Notice It MUST emit when IDistributor#removedistribution is called. DistributionAdded # Event emitted when a distribution is added. event DistributionAdded(bytes32 id, address initializer) Input Type Description id bytes32 The unique identifier of the distribution that was added. initializer address The address of the initializer that was added. Notice It MUST emit when IDistributor#adddistribution is called. getDistributions # Retrieves the unique identifiers of all distributions. function getDistributions() external view returns (bytes32[] distributorIds) Output Type Description distributorIds bytes32[] An array of unique identifiers of all distributions. getDistributionURI # Retrieves the URI of the distribution. function getDistributionURI(bytes32 distributorId) external view returns (string) Input Type Description distributorId bytes32 The unique identifier of the distribution. Output 0 string uri The URI of the distribution. instantiate # Instantiates a new instance with the given distributor ID and arguments. function instantiate(bytes32 distributorId, bytes args) external returns (address[], bytes32 distributionName, uint256 distributionVersion) Input Type Description distributorId bytes32 The unique identifier of the distributor. args bytes The arguments to be used for instantiation. Output 0 address[] instances The addresses of the instances that were created. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. Notice It MUST emit Instantiated event. addDistribution # function addDistribution(bytes32 distributorId, address initializer) external removeDistribution # function removeDistribution(bytes32 distributorId) external getDistributionId # function getDistributionId(address instance) external view returns (bytes32) getInstanceId # function getInstanceId(address instance) external view returns (uint256)","title":"IDistributor Interface"},{"location":"Ethereum%20Distribution%20System/IDistributor/#idistributor-interface","text":"Defines the standard functions for a distributor contract. Notice If you want to use IRepository for versioned distributions, use IVersionDistributor interface.","title":"IDistributor Interface"},{"location":"Ethereum%20Distribution%20System/IDistributor/#distributionnotfound","text":"Error indicating that the distribution with the specified ID was not found. error DistributionNotFound(bytes32 id) Input Type Description id bytes32 The unique identifier of the distribution that was not found.","title":"DistributionNotFound"},{"location":"Ethereum%20Distribution%20System/IDistributor/#distributionexists","text":"Error indicating that a distribution with the specified ID already exists. error DistributionExists(bytes32 id) Input Type Description id bytes32 The unique identifier of the distribution that already exists.","title":"DistributionExists"},{"location":"Ethereum%20Distribution%20System/IDistributor/#initializernotfound","text":"Error indicating that the initializer for the distribution was not found. error InitializerNotFound(bytes32 id) Input Type Description id bytes32 The unique identifier of the distribution that was not found.","title":"InitializerNotFound"},{"location":"Ethereum%20Distribution%20System/IDistributor/#invalidinstance","text":"Error indicating that the instance is invalid. error InvalidInstance(address instance) Input Type Description instance address The address of the instance that is considered invalid.","title":"InvalidInstance"},{"location":"Ethereum%20Distribution%20System/IDistributor/#instantiated","text":"Event emitted when a new distribution is instantiated. event Instantiated(bytes32 distributionId, uint256 instanceId, bytes argsHash, address[] instances) Input Type Description distributionId bytes32 The unique identifier of the distribution. instanceId uint256 The unique identifier of the instance. argsHash bytes The hash of the arguments used to instantiate the distribution. instances address[] The addresses of the instances that were created. Notice It MUST emit when IDistributor#instantiate is called.","title":"Instantiated"},{"location":"Ethereum%20Distribution%20System/IDistributor/#distributionremoved","text":"Event emitted when a distribution is removed. event DistributionRemoved(bytes32 id) Input Type Description id bytes32 The unique identifier of the distribution that was removed. Notice It MUST emit when IDistributor#removedistribution is called.","title":"DistributionRemoved"},{"location":"Ethereum%20Distribution%20System/IDistributor/#distributionadded","text":"Event emitted when a distribution is added. event DistributionAdded(bytes32 id, address initializer) Input Type Description id bytes32 The unique identifier of the distribution that was added. initializer address The address of the initializer that was added. Notice It MUST emit when IDistributor#adddistribution is called.","title":"DistributionAdded"},{"location":"Ethereum%20Distribution%20System/IDistributor/#getdistributions","text":"Retrieves the unique identifiers of all distributions. function getDistributions() external view returns (bytes32[] distributorIds) Output Type Description distributorIds bytes32[] An array of unique identifiers of all distributions.","title":"getDistributions"},{"location":"Ethereum%20Distribution%20System/IDistributor/#getdistributionuri","text":"Retrieves the URI of the distribution. function getDistributionURI(bytes32 distributorId) external view returns (string) Input Type Description distributorId bytes32 The unique identifier of the distribution. Output 0 string uri The URI of the distribution.","title":"getDistributionURI"},{"location":"Ethereum%20Distribution%20System/IDistributor/#instantiate","text":"Instantiates a new instance with the given distributor ID and arguments. function instantiate(bytes32 distributorId, bytes args) external returns (address[], bytes32 distributionName, uint256 distributionVersion) Input Type Description distributorId bytes32 The unique identifier of the distributor. args bytes The arguments to be used for instantiation. Output 0 address[] instances The addresses of the instances that were created. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. Notice It MUST emit Instantiated event.","title":"instantiate"},{"location":"Ethereum%20Distribution%20System/IDistributor/#adddistribution","text":"function addDistribution(bytes32 distributorId, address initializer) external","title":"addDistribution"},{"location":"Ethereum%20Distribution%20System/IDistributor/#removedistribution","text":"function removeDistribution(bytes32 distributorId) external","title":"removeDistribution"},{"location":"Ethereum%20Distribution%20System/IDistributor/#getdistributionid","text":"function getDistributionId(address instance) external view returns (bytes32)","title":"getDistributionId"},{"location":"Ethereum%20Distribution%20System/IDistributor/#getinstanceid","text":"function getInstanceId(address instance) external view returns (uint256)","title":"getInstanceId"},{"location":"Ethereum%20Distribution%20System/IERC7746/","text":"IERC7746 Interface # Notice Interface for the ERC7746 standard. beforeCall # Validates a function call before execution. function beforeCall(bytes configuration, bytes4 selector, address sender, uint256 value, bytes data) external returns (bytes) Input Type Description configuration bytes Middleware-specific configuration data. selector bytes4 The function selector being called. sender address The address initiating the call. value uint256 The amount of ETH sent with the call (if any). data bytes The calldata for the function call. Output 0 bytes beforeCallResult Arbitrary data to be passed to afterCallValidation . Notice MUST revert if validation fails. afterCall # Validates a function call after execution. function afterCall(bytes configuration, bytes4 selector, address sender, uint256 value, bytes data, bytes beforeCallResult) external Input Type Description configuration bytes Middleware-specific configuration data. selector bytes4 The function selector being called. sender address The address initiating the call. value uint256 The amount of ETH sent with the call (if any). data bytes The calldata for the function call. beforeCallResult bytes The data returned by beforeCallValidation . Notice MUST revert if validation fails.","title":"IERC7746 Interface"},{"location":"Ethereum%20Distribution%20System/IERC7746/#ierc7746-interface","text":"Notice Interface for the ERC7746 standard.","title":"IERC7746 Interface"},{"location":"Ethereum%20Distribution%20System/IERC7746/#beforecall","text":"Validates a function call before execution. function beforeCall(bytes configuration, bytes4 selector, address sender, uint256 value, bytes data) external returns (bytes) Input Type Description configuration bytes Middleware-specific configuration data. selector bytes4 The function selector being called. sender address The address initiating the call. value uint256 The amount of ETH sent with the call (if any). data bytes The calldata for the function call. Output 0 bytes beforeCallResult Arbitrary data to be passed to afterCallValidation . Notice MUST revert if validation fails.","title":"beforeCall"},{"location":"Ethereum%20Distribution%20System/IERC7746/#aftercall","text":"Validates a function call after execution. function afterCall(bytes configuration, bytes4 selector, address sender, uint256 value, bytes data, bytes beforeCallResult) external Input Type Description configuration bytes Middleware-specific configuration data. selector bytes4 The function selector being called. sender address The address initiating the call. value uint256 The amount of ETH sent with the call (if any). data bytes The calldata for the function call. beforeCallResult bytes The data returned by beforeCallValidation . Notice MUST revert if validation fails.","title":"afterCall"},{"location":"Ethereum%20Distribution%20System/IInitializer/","text":"IInitializer # Interface for the Initializer contract. This is intended to be used as distribution initializer within the Distributor contract. Initialized # event Initialized(address container, bytes32 codeHash) initializationFailed # error initializationFailed(bytes32 id, string reason) initialize # Initializes the contract with necessary parameters. function initialize(bytes32 distributionId, address[] instances, bytes32 distributionName, uint256 distributionVersion, bytes args) external Input Type Description distributionId bytes32 The ID of the distribution being initialized instances address[] The addresses of the instances being initialized distributionName bytes32 The name of the distribution distributionVersion uint256 The version of the distribution args bytes The additional arguments to be used for initialization Notice This function should be delegete-called by the distributor contract.","title":"IInitializer"},{"location":"Ethereum%20Distribution%20System/IInitializer/#iinitializer","text":"Interface for the Initializer contract. This is intended to be used as distribution initializer within the Distributor contract.","title":"IInitializer"},{"location":"Ethereum%20Distribution%20System/IInitializer/#initialized","text":"event Initialized(address container, bytes32 codeHash)","title":"Initialized"},{"location":"Ethereum%20Distribution%20System/IInitializer/#initializationfailed","text":"error initializationFailed(bytes32 id, string reason)","title":"initializationFailed"},{"location":"Ethereum%20Distribution%20System/IInitializer/#initialize","text":"Initializes the contract with necessary parameters. function initialize(bytes32 distributionId, address[] instances, bytes32 distributionName, uint256 distributionVersion, bytes args) external Input Type Description distributionId bytes32 The ID of the distribution being initialized instances address[] The addresses of the instances being initialized distributionName bytes32 The name of the distribution distributionVersion uint256 The version of the distribution args bytes The additional arguments to be used for initialization Notice This function should be delegete-called by the distributor contract.","title":"initialize"},{"location":"Ethereum%20Distribution%20System/IInstaller/","text":"IInstaller Interface # Enables target smart account to interact with Distributor contract ecosystem. NotAnInstance # error NotAnInstance(address instance) Input Type Description instance address The address that was checked and found not to be an instance. Notice Error indicating that the provided address is not a valid instance. InvalidDistributor # Error indicating that the provided distributor is invalid. error InvalidDistributor(contract IDistributor distributor) Input Type Description distributor contract IDistributor The distributor that is considered invalid. InvalidTarget # error InvalidTarget(address target) Input Type Description target address The address that is considered invalid. Notice Error indicating that the provided target address is not the smart account installer serves. alreadyAllowed # Error indicating that the specified distributor is already allowed. error alreadyAllowed(contract IDistributor distributor) Input Type Description distributor contract IDistributor The distributor that is already allowed. DistributionIsNotPermitted # Error indicating that a distribution is not permitted (not installed). error DistributionIsNotPermitted(contract IDistributor distributor, bytes32 distributionId) Input Type Description distributor contract IDistributor The address of the distributor containing the distribution. distributionId bytes32 The unique identifier of the distribution. DissalowDistOnWhitelistedDistributor # Error indicating that distributor is whitelisted and hence it is not possible to selectively dissalow distriributions. error DissalowDistOnWhitelistedDistributor(contract IDistributor distributor, bytes32 distributionId) Input Type Description distributor contract IDistributor The whitelisted distributor. distributionId bytes32 The ID of the distribution that was attempted to dissalow. Notice If getting this error: consider first removing distributor from whitelist, and then dissalowing the distribution. DistributorWhitelisted # event DistributorWhitelisted(contract IDistributor distributor) Input Type Description distributor contract IDistributor The address of the distributor that has been whitelisted. Notice Emitted when a distributor is whitelisted. Any distribution of the whitelisted distributor MUST be allowed to be installed. DistributorWhitelistRevoked # Emitted when a distributor is removed from the whitelist. event DistributorWhitelistRevoked(contract IDistributor distributor) Input Type Description distributor contract IDistributor The address of the distributor that was revoked. Warning After removal, the distributions that were allowed by id are still allowed. DistributionAllowed # event DistributionAllowed(contract IDistributor distributor, bytes32 distributionId) Input Type Description distributor contract IDistributor The address of the distributor that is allowed. distributionId bytes32 The unique identifier of the distribution. Notice Emitted when a distribution is allowed by the installer. DistributionDisallowed # event DistributionDisallowed(contract IDistributor distributor, bytes32 distributionId) Input Type Description distributor contract IDistributor The address of the distributor that is disallowed. distributionId bytes32 The unique identifier of the distribution that is disallowed. Notice Emitted when a distribution is disallowed by the installer. allowDistribution # Allows a specified distributor to distribute a given distribution ID. function allowDistribution(contract IDistributor distributor, bytes32 distributionId) external Input Type Description distributor contract IDistributor The address of the distributor hosting a distribution Id. distributionId bytes32 The ID of the distribution to be allowed. Notice MUST emit DistributionAllowed event. disallowDistribution # Disallows a specific distribution from a given distributor. function disallowDistribution(contract IDistributor distributor, bytes32 distributionId) external Input Type Description distributor contract IDistributor The address of the distributor contract. distributionId bytes32 The unique identifier of the distribution to be disallowed. Notice MUST emit DistributionDisallowed event. whitelistedDistributions # Retrieves the list of whitelisted distributions for a given distributor. function whitelistedDistributions(contract IDistributor distributor) external view returns (bytes32[]) Input Type Description distributor contract IDistributor The address of the distributor to query. Output 0 bytes32[] An array of bytes32 representing the whitelisted distributions. Notice If the distributor is whitelisted, all distributions are allowed. whitelistDistributor # Adds a distributor to the whitelist. function whitelistDistributor(contract IDistributor distributor) external Input Type Description distributor contract IDistributor The address of the distributor to be whitelisted. Notice After whitelisting, all distributions of the distributor are allowed. Must emit DistributorWhitelisted event. revokeWhitelistedDistributor # Revokes the whitelisted status of a given distributor. function revokeWhitelistedDistributor(contract IDistributor distributor) external Input Type Description distributor contract IDistributor The address of the distributor to be revoked. Notice After revoking, the distributions that were allowed by id are still allowed. Must emit DistributorWhitelistRevoked event. isDistributor # Checks if the given address is a valid distributor. function isDistributor(contract IDistributor distributor) external view returns (bool) Input Type Description distributor contract IDistributor The address of the distributor to check. Output 0 bool bool Returns true if the address is a valid distributor, otherwise false. getWhitelistedDistributors # Retrieves the list of whitelisted distributor addresses. function getWhitelistedDistributors() external view returns (address[]) Output Type Description 0 address[] An array of addresses that are whitelisted as distributors. Installed # event Installed(address instance, bytes32 distributionId, bytes32 permissions, bytes args) Input Type Description instance address The address of the installed instance. distributionId bytes32 The identifier of the distribution. permissions bytes32 The permissions associated with the installation. args bytes Additional arguments related to the installation. Notice Emitted when an instance is installed. MUST be emitted for every new instance installed via install function. Uninstalled # event Uninstalled(address instance) install # Installs a new instance with the given distributor, distribution ID, and arguments. function install(contract IDistributor distributor, bytes32 distributionId, bytes args) external payable returns (uint256 instanceId) Input Type Description distributor contract IDistributor The distributor contract to be used for the installation. distributionId bytes32 The unique identifier for the distribution. args bytes Additional arguments required for the installation process. Output instanceId uint256 The unique identifier of the newly installed instance. Notice MUST emit Installed event per installed instance. MUST revert if the distributor is not whitelisted or the distribution is not allowed. MUST revert if the distributor is not a valid distributor. After succesfull installation ERC77446 hooks SHALL NOT revert if called by target, specifying active instance in sender field. uninstall # Uninstalls an instance with the given ID. function uninstall(uint256 instanceId) external Input Type Description instanceId uint256 The unique identifier of the instance to be uninstalled. Notice MUST emit Uninstalled event per uninstalled instance. MUST revert if the instance is not installed. After succesfull uninstallation ERC77446 hooks SHALL revert if called by target, specifying uninstalled instance in sender field. getInstance # Retrieves the contracts associated with a specific instance. function getInstance(uint256 instanceId) external view returns (address[] instaneContracts) Input Type Description instanceId uint256 The unique identifier of the instance. Output instaneContracts address[] An array of addresses representing the contracts of the instance. getInstancesNum # Retrieves the number of instances. function getInstancesNum() external view returns (uint256) Output Type Description 0 uint256 The total number of instances as a uint256. Notice this number SHALL NOT decrease after uninstallation. isInstance # Checks if the given address is an active instance. function isInstance(address instance) external view returns (bool) Input Type Description instance address The address to check. Output 0 bool bool True if the address is an instance, false otherwise. distributorOf # Returns the distributor associated with a given instance. function distributorOf(address instance) external view returns (contract IDistributor) Input Type Description instance address The address of the instance for which the distributor is being queried. Output 0 contract IDistributor The distributor associated with the specified instance. target # Retrieves the address of the target contract. function target() external view returns (address) Output Type Description 0 address The address of the target contract.","title":"IInstaller Interface"},{"location":"Ethereum%20Distribution%20System/IInstaller/#iinstaller-interface","text":"Enables target smart account to interact with Distributor contract ecosystem.","title":"IInstaller Interface"},{"location":"Ethereum%20Distribution%20System/IInstaller/#notaninstance","text":"error NotAnInstance(address instance) Input Type Description instance address The address that was checked and found not to be an instance. Notice Error indicating that the provided address is not a valid instance.","title":"NotAnInstance"},{"location":"Ethereum%20Distribution%20System/IInstaller/#invaliddistributor","text":"Error indicating that the provided distributor is invalid. error InvalidDistributor(contract IDistributor distributor) Input Type Description distributor contract IDistributor The distributor that is considered invalid.","title":"InvalidDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#invalidtarget","text":"error InvalidTarget(address target) Input Type Description target address The address that is considered invalid. Notice Error indicating that the provided target address is not the smart account installer serves.","title":"InvalidTarget"},{"location":"Ethereum%20Distribution%20System/IInstaller/#alreadyallowed","text":"Error indicating that the specified distributor is already allowed. error alreadyAllowed(contract IDistributor distributor) Input Type Description distributor contract IDistributor The distributor that is already allowed.","title":"alreadyAllowed"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributionisnotpermitted","text":"Error indicating that a distribution is not permitted (not installed). error DistributionIsNotPermitted(contract IDistributor distributor, bytes32 distributionId) Input Type Description distributor contract IDistributor The address of the distributor containing the distribution. distributionId bytes32 The unique identifier of the distribution.","title":"DistributionIsNotPermitted"},{"location":"Ethereum%20Distribution%20System/IInstaller/#dissalowdistonwhitelisteddistributor","text":"Error indicating that distributor is whitelisted and hence it is not possible to selectively dissalow distriributions. error DissalowDistOnWhitelistedDistributor(contract IDistributor distributor, bytes32 distributionId) Input Type Description distributor contract IDistributor The whitelisted distributor. distributionId bytes32 The ID of the distribution that was attempted to dissalow. Notice If getting this error: consider first removing distributor from whitelist, and then dissalowing the distribution.","title":"DissalowDistOnWhitelistedDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributorwhitelisted","text":"event DistributorWhitelisted(contract IDistributor distributor) Input Type Description distributor contract IDistributor The address of the distributor that has been whitelisted. Notice Emitted when a distributor is whitelisted. Any distribution of the whitelisted distributor MUST be allowed to be installed.","title":"DistributorWhitelisted"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributorwhitelistrevoked","text":"Emitted when a distributor is removed from the whitelist. event DistributorWhitelistRevoked(contract IDistributor distributor) Input Type Description distributor contract IDistributor The address of the distributor that was revoked. Warning After removal, the distributions that were allowed by id are still allowed.","title":"DistributorWhitelistRevoked"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributionallowed","text":"event DistributionAllowed(contract IDistributor distributor, bytes32 distributionId) Input Type Description distributor contract IDistributor The address of the distributor that is allowed. distributionId bytes32 The unique identifier of the distribution. Notice Emitted when a distribution is allowed by the installer.","title":"DistributionAllowed"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributiondisallowed","text":"event DistributionDisallowed(contract IDistributor distributor, bytes32 distributionId) Input Type Description distributor contract IDistributor The address of the distributor that is disallowed. distributionId bytes32 The unique identifier of the distribution that is disallowed. Notice Emitted when a distribution is disallowed by the installer.","title":"DistributionDisallowed"},{"location":"Ethereum%20Distribution%20System/IInstaller/#allowdistribution","text":"Allows a specified distributor to distribute a given distribution ID. function allowDistribution(contract IDistributor distributor, bytes32 distributionId) external Input Type Description distributor contract IDistributor The address of the distributor hosting a distribution Id. distributionId bytes32 The ID of the distribution to be allowed. Notice MUST emit DistributionAllowed event.","title":"allowDistribution"},{"location":"Ethereum%20Distribution%20System/IInstaller/#disallowdistribution","text":"Disallows a specific distribution from a given distributor. function disallowDistribution(contract IDistributor distributor, bytes32 distributionId) external Input Type Description distributor contract IDistributor The address of the distributor contract. distributionId bytes32 The unique identifier of the distribution to be disallowed. Notice MUST emit DistributionDisallowed event.","title":"disallowDistribution"},{"location":"Ethereum%20Distribution%20System/IInstaller/#whitelisteddistributions","text":"Retrieves the list of whitelisted distributions for a given distributor. function whitelistedDistributions(contract IDistributor distributor) external view returns (bytes32[]) Input Type Description distributor contract IDistributor The address of the distributor to query. Output 0 bytes32[] An array of bytes32 representing the whitelisted distributions. Notice If the distributor is whitelisted, all distributions are allowed.","title":"whitelistedDistributions"},{"location":"Ethereum%20Distribution%20System/IInstaller/#whitelistdistributor","text":"Adds a distributor to the whitelist. function whitelistDistributor(contract IDistributor distributor) external Input Type Description distributor contract IDistributor The address of the distributor to be whitelisted. Notice After whitelisting, all distributions of the distributor are allowed. Must emit DistributorWhitelisted event.","title":"whitelistDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#revokewhitelisteddistributor","text":"Revokes the whitelisted status of a given distributor. function revokeWhitelistedDistributor(contract IDistributor distributor) external Input Type Description distributor contract IDistributor The address of the distributor to be revoked. Notice After revoking, the distributions that were allowed by id are still allowed. Must emit DistributorWhitelistRevoked event.","title":"revokeWhitelistedDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#isdistributor","text":"Checks if the given address is a valid distributor. function isDistributor(contract IDistributor distributor) external view returns (bool) Input Type Description distributor contract IDistributor The address of the distributor to check. Output 0 bool bool Returns true if the address is a valid distributor, otherwise false.","title":"isDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#getwhitelisteddistributors","text":"Retrieves the list of whitelisted distributor addresses. function getWhitelistedDistributors() external view returns (address[]) Output Type Description 0 address[] An array of addresses that are whitelisted as distributors.","title":"getWhitelistedDistributors"},{"location":"Ethereum%20Distribution%20System/IInstaller/#installed","text":"event Installed(address instance, bytes32 distributionId, bytes32 permissions, bytes args) Input Type Description instance address The address of the installed instance. distributionId bytes32 The identifier of the distribution. permissions bytes32 The permissions associated with the installation. args bytes Additional arguments related to the installation. Notice Emitted when an instance is installed. MUST be emitted for every new instance installed via install function.","title":"Installed"},{"location":"Ethereum%20Distribution%20System/IInstaller/#uninstalled","text":"event Uninstalled(address instance)","title":"Uninstalled"},{"location":"Ethereum%20Distribution%20System/IInstaller/#install","text":"Installs a new instance with the given distributor, distribution ID, and arguments. function install(contract IDistributor distributor, bytes32 distributionId, bytes args) external payable returns (uint256 instanceId) Input Type Description distributor contract IDistributor The distributor contract to be used for the installation. distributionId bytes32 The unique identifier for the distribution. args bytes Additional arguments required for the installation process. Output instanceId uint256 The unique identifier of the newly installed instance. Notice MUST emit Installed event per installed instance. MUST revert if the distributor is not whitelisted or the distribution is not allowed. MUST revert if the distributor is not a valid distributor. After succesfull installation ERC77446 hooks SHALL NOT revert if called by target, specifying active instance in sender field.","title":"install"},{"location":"Ethereum%20Distribution%20System/IInstaller/#uninstall","text":"Uninstalls an instance with the given ID. function uninstall(uint256 instanceId) external Input Type Description instanceId uint256 The unique identifier of the instance to be uninstalled. Notice MUST emit Uninstalled event per uninstalled instance. MUST revert if the instance is not installed. After succesfull uninstallation ERC77446 hooks SHALL revert if called by target, specifying uninstalled instance in sender field.","title":"uninstall"},{"location":"Ethereum%20Distribution%20System/IInstaller/#getinstance","text":"Retrieves the contracts associated with a specific instance. function getInstance(uint256 instanceId) external view returns (address[] instaneContracts) Input Type Description instanceId uint256 The unique identifier of the instance. Output instaneContracts address[] An array of addresses representing the contracts of the instance.","title":"getInstance"},{"location":"Ethereum%20Distribution%20System/IInstaller/#getinstancesnum","text":"Retrieves the number of instances. function getInstancesNum() external view returns (uint256) Output Type Description 0 uint256 The total number of instances as a uint256. Notice this number SHALL NOT decrease after uninstallation.","title":"getInstancesNum"},{"location":"Ethereum%20Distribution%20System/IInstaller/#isinstance","text":"Checks if the given address is an active instance. function isInstance(address instance) external view returns (bool) Input Type Description instance address The address to check. Output 0 bool bool True if the address is an instance, false otherwise.","title":"isInstance"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributorof","text":"Returns the distributor associated with a given instance. function distributorOf(address instance) external view returns (contract IDistributor) Input Type Description instance address The address of the instance for which the distributor is being queried. Output 0 contract IDistributor The distributor associated with the specified instance.","title":"distributorOf"},{"location":"Ethereum%20Distribution%20System/IInstaller/#target","text":"Retrieves the address of the target contract. function target() external view returns (address) Output Type Description 0 address The address of the target contract.","title":"target"},{"location":"Ethereum%20Distribution%20System/IRepository/","text":"IRepository Interface # It is intended to be implemented by contracts that manage a collection of versions of a byte code. Source # Represents a source with version information, a unique identifier, and associated metadata. Input Type Description struct Source { struct LibSemver.Version version; bytes32 sourceId; bytes metadata; } VersionDoesNotExist # Error indicating that the specified version does not exist. error VersionDoesNotExist(uint256 version) Input Type Description version uint256 The version number that does not exist. ReleaseZeroNotAllowed # Error indicating that a release with a zero value is not allowed. error ReleaseZeroNotAllowed() VersionExists # Error indicating that the specified version already exists. error VersionExists(uint256 version) Input Type Description version uint256 The version number that already exists. VersionIncrementInvalid # Error indicating that the version increment is invalid. error VersionIncrementInvalid(uint256 version) Input Type Description version uint256 The version number that caused the error. Notice The version increment must be exactly one for either major, minor, or patch. EmptyReleaseMetadata # error EmptyReleaseMetadata() Notice Error indicating that the release metadata is empty. VersionAdded # Emitted when a new version is added to the repository. event VersionAdded(uint256 version, bytes32 source, bytes buildMetadata) Input Type Description version uint256 The version number of the added item. source bytes32 The source identifier of the added item. buildMetadata bytes Additional metadata related to the build. ReleaseMetadataUpdated # Emitted when the metadata of a release is updated. event ReleaseMetadataUpdated(uint256 version, bytes releaseMetadata) Input Type Description version uint256 The version number of the release. releaseMetadata bytes The metadata associated with the release. updateReleaseMetadata # Updates the metadata for a specific release version. function updateReleaseMetadata(struct LibSemver.Version version, bytes releaseMetadata) external Input Type Description version struct LibSemver.Version The version of the release to update. releaseMetadata bytes The new metadata to associate with the release. Notice It MUST emit ReleaseMetadataUpdated event. repositoryName # Retrieves the name of the repository. function repositoryName() external view returns (bytes32) Output Type Description 0 bytes32 The name of the repository as a bytes32 value. newRelease # Creates a new release for the given source ID. function newRelease(bytes32 sourceId, bytes metadata, struct LibSemver.Version version) external Input Type Description sourceId bytes32 The unique identifier of the source. metadata bytes The metadata associated with the release. version struct LibSemver.Version The semantic version of the new release. Notice It MUST emit VersionAdded event. getLatest # Retrieves the latest source. function getLatest() external view returns (struct IRepository.Source) Output Type Description 0 struct IRepository.Source The requested source get # Retrieves a specific item from the repository. function get(struct LibSemver.Version baseVersion, enum LibSemver.requirements requirement) external view returns (struct IRepository.Source) Input Type Description baseVersion struct LibSemver.Version the base of required version requirement enum LibSemver.requirements the requirement of the version Output 0 struct IRepository.Source The requested Source .","title":"IRepository Interface"},{"location":"Ethereum%20Distribution%20System/IRepository/#irepository-interface","text":"It is intended to be implemented by contracts that manage a collection of versions of a byte code.","title":"IRepository Interface"},{"location":"Ethereum%20Distribution%20System/IRepository/#source","text":"Represents a source with version information, a unique identifier, and associated metadata. Input Type Description struct Source { struct LibSemver.Version version; bytes32 sourceId; bytes metadata; }","title":"Source"},{"location":"Ethereum%20Distribution%20System/IRepository/#versiondoesnotexist","text":"Error indicating that the specified version does not exist. error VersionDoesNotExist(uint256 version) Input Type Description version uint256 The version number that does not exist.","title":"VersionDoesNotExist"},{"location":"Ethereum%20Distribution%20System/IRepository/#releasezeronotallowed","text":"Error indicating that a release with a zero value is not allowed. error ReleaseZeroNotAllowed()","title":"ReleaseZeroNotAllowed"},{"location":"Ethereum%20Distribution%20System/IRepository/#versionexists","text":"Error indicating that the specified version already exists. error VersionExists(uint256 version) Input Type Description version uint256 The version number that already exists.","title":"VersionExists"},{"location":"Ethereum%20Distribution%20System/IRepository/#versionincrementinvalid","text":"Error indicating that the version increment is invalid. error VersionIncrementInvalid(uint256 version) Input Type Description version uint256 The version number that caused the error. Notice The version increment must be exactly one for either major, minor, or patch.","title":"VersionIncrementInvalid"},{"location":"Ethereum%20Distribution%20System/IRepository/#emptyreleasemetadata","text":"error EmptyReleaseMetadata() Notice Error indicating that the release metadata is empty.","title":"EmptyReleaseMetadata"},{"location":"Ethereum%20Distribution%20System/IRepository/#versionadded","text":"Emitted when a new version is added to the repository. event VersionAdded(uint256 version, bytes32 source, bytes buildMetadata) Input Type Description version uint256 The version number of the added item. source bytes32 The source identifier of the added item. buildMetadata bytes Additional metadata related to the build.","title":"VersionAdded"},{"location":"Ethereum%20Distribution%20System/IRepository/#releasemetadataupdated","text":"Emitted when the metadata of a release is updated. event ReleaseMetadataUpdated(uint256 version, bytes releaseMetadata) Input Type Description version uint256 The version number of the release. releaseMetadata bytes The metadata associated with the release.","title":"ReleaseMetadataUpdated"},{"location":"Ethereum%20Distribution%20System/IRepository/#updatereleasemetadata","text":"Updates the metadata for a specific release version. function updateReleaseMetadata(struct LibSemver.Version version, bytes releaseMetadata) external Input Type Description version struct LibSemver.Version The version of the release to update. releaseMetadata bytes The new metadata to associate with the release. Notice It MUST emit ReleaseMetadataUpdated event.","title":"updateReleaseMetadata"},{"location":"Ethereum%20Distribution%20System/IRepository/#repositoryname","text":"Retrieves the name of the repository. function repositoryName() external view returns (bytes32) Output Type Description 0 bytes32 The name of the repository as a bytes32 value.","title":"repositoryName"},{"location":"Ethereum%20Distribution%20System/IRepository/#newrelease","text":"Creates a new release for the given source ID. function newRelease(bytes32 sourceId, bytes metadata, struct LibSemver.Version version) external Input Type Description sourceId bytes32 The unique identifier of the source. metadata bytes The metadata associated with the release. version struct LibSemver.Version The semantic version of the new release. Notice It MUST emit VersionAdded event.","title":"newRelease"},{"location":"Ethereum%20Distribution%20System/IRepository/#getlatest","text":"Retrieves the latest source. function getLatest() external view returns (struct IRepository.Source) Output Type Description 0 struct IRepository.Source The requested source","title":"getLatest"},{"location":"Ethereum%20Distribution%20System/IRepository/#get","text":"Retrieves a specific item from the repository. function get(struct LibSemver.Version baseVersion, enum LibSemver.requirements requirement) external view returns (struct IRepository.Source) Input Type Description baseVersion struct LibSemver.Version the base of required version requirement enum LibSemver.requirements the requirement of the version Output 0 struct IRepository.Source The requested Source .","title":"get"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/","text":"# InvalidRepository # error InvalidRepository(contract IRepository repository) RepositoryAlreadyExists # error RepositoryAlreadyExists(contract IRepository repository) VersionOutdated # error VersionOutdated(contract IRepository repository, uint256 version) InvalidInstance # error InvalidInstance(address instance) VersionedDistributionAdded # event VersionedDistributionAdded(contract IRepository repository, uint256 version, enum LibSemver.requirements requirement, address initializer) VersionChanged # event VersionChanged(address repository, uint256 oldVersion, uint256 newVersion) RequirementChanged # event RequirementChanged(contract IRepository repository, enum LibSemver.requirements oldRequirement, enum LibSemver.requirements newRequirement) VersionedDistributionRemoved # event VersionedDistributionRemoved(contract IRepository repository) Instantiated # event Instantiated(address repository, bytes argsHash) addVersionedDistribution # function addVersionedDistribution(contract IRepository repository, struct LibSemver.Version version, enum LibSemver.requirements requirement, address initializer) external changeRequirement # function changeRequirement(contract IRepository repository, struct LibSemver.Version version, enum LibSemver.requirements requirement) external getVersionedDistributions # function getVersionedDistributions() external view returns (address[] repositories) getVersionedDistributionURI # function getVersionedDistributionURI(contract IRepository repository) external view returns (string) instantiate # function instantiate(contract IRepository repository, bytes args) external returns (address[], bytes32, uint256) removeVersionedDistribution # function removeVersionedDistribution(contract IRepository repository) external","title":"IVersionDistributor"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#_1","text":"","title":""},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#invalidrepository","text":"error InvalidRepository(contract IRepository repository)","title":"InvalidRepository"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#repositoryalreadyexists","text":"error RepositoryAlreadyExists(contract IRepository repository)","title":"RepositoryAlreadyExists"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#versionoutdated","text":"error VersionOutdated(contract IRepository repository, uint256 version)","title":"VersionOutdated"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#invalidinstance","text":"error InvalidInstance(address instance)","title":"InvalidInstance"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#versioneddistributionadded","text":"event VersionedDistributionAdded(contract IRepository repository, uint256 version, enum LibSemver.requirements requirement, address initializer)","title":"VersionedDistributionAdded"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#versionchanged","text":"event VersionChanged(address repository, uint256 oldVersion, uint256 newVersion)","title":"VersionChanged"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#requirementchanged","text":"event RequirementChanged(contract IRepository repository, enum LibSemver.requirements oldRequirement, enum LibSemver.requirements newRequirement)","title":"RequirementChanged"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#versioneddistributionremoved","text":"event VersionedDistributionRemoved(contract IRepository repository)","title":"VersionedDistributionRemoved"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#instantiated","text":"event Instantiated(address repository, bytes argsHash)","title":"Instantiated"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#addversioneddistribution","text":"function addVersionedDistribution(contract IRepository repository, struct LibSemver.Version version, enum LibSemver.requirements requirement, address initializer) external","title":"addVersionedDistribution"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#changerequirement","text":"function changeRequirement(contract IRepository repository, struct LibSemver.Version version, enum LibSemver.requirements requirement) external","title":"changeRequirement"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#getversioneddistributions","text":"function getVersionedDistributions() external view returns (address[] repositories)","title":"getVersionedDistributions"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#getversioneddistributionuri","text":"function getVersionedDistributionURI(contract IRepository repository) external view returns (string)","title":"getVersionedDistributionURI"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#instantiate","text":"function instantiate(contract IRepository repository, bytes args) external returns (address[], bytes32, uint256)","title":"instantiate"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#removeversioneddistribution","text":"function removeVersionedDistribution(contract IRepository repository) external","title":"removeVersionedDistribution"},{"location":"architecture/","text":"Overview # We are using Ethereum Distribution System to enable users to deploy their own infrastructure in transparent and decentralized way. In order to be out of box compatible with the interfaces & notifications of the Rankify platform, any deployment should should be done from the Peeramid Labs Distributor contract ( PeeramidLabsDistributor.sol ). Specific address for distributor deployment can be found in the deployments github directory . Warning This is a work in progress, and the documentation is not yet complete. It will change over time. MAODistribution contract # MAODistribution.sol is used to create a new Meritocratic Autonomous Organization (MAO). This deployment will create following infrastructure: RankToken - ERC1155 token used to represent the ranks in the MAO. Governance token - ERC20 token used to represent the governance in the MAO. ACID Distribution - Arguable Voting Tournament contract used to distribute governance tokens. Aragon OSx DAO - Aragon DAO used as wrapped smart account that represents the MAO. Aragon Token Voting Plugin - Aragon plugin used to vote on proposals within the DAO. ACID distribution # ArguableVotingTournament.sol is used to distribute governance tokens to the participants of the MAO by conducting autonomous competence identification tournaments. This distribution deploys the Diamond Proxy that contains the following facets: EIP712InspectorFacet - Facet that contains the main logic of the distribution. RankifyInstanceMainFacet - Facet that contains the main logic of the distribution. RankifyGameMastersFacetFacet - Facet that contains the main logic of the distribution. RankifyInstanceGameOwnersFacet - Facet that contains the ownable logic of the distribution. (NB this will be deprecated) RankifyInstanceRequirementsFacet - Facet that contains the requirements logic of the distribution. If you have any further questions to clarify, please feel free to ask in the Rankify Discord .","title":"Overview"},{"location":"architecture/#overview","text":"We are using Ethereum Distribution System to enable users to deploy their own infrastructure in transparent and decentralized way. In order to be out of box compatible with the interfaces & notifications of the Rankify platform, any deployment should should be done from the Peeramid Labs Distributor contract ( PeeramidLabsDistributor.sol ). Specific address for distributor deployment can be found in the deployments github directory . Warning This is a work in progress, and the documentation is not yet complete. It will change over time.","title":"Overview"},{"location":"architecture/#maodistribution-contract","text":"MAODistribution.sol is used to create a new Meritocratic Autonomous Organization (MAO). This deployment will create following infrastructure: RankToken - ERC1155 token used to represent the ranks in the MAO. Governance token - ERC20 token used to represent the governance in the MAO. ACID Distribution - Arguable Voting Tournament contract used to distribute governance tokens. Aragon OSx DAO - Aragon DAO used as wrapped smart account that represents the MAO. Aragon Token Voting Plugin - Aragon plugin used to vote on proposals within the DAO.","title":"MAODistribution contract"},{"location":"architecture/#acid-distribution","text":"ArguableVotingTournament.sol is used to distribute governance tokens to the participants of the MAO by conducting autonomous competence identification tournaments. This distribution deploys the Diamond Proxy that contains the following facets: EIP712InspectorFacet - Facet that contains the main logic of the distribution. RankifyInstanceMainFacet - Facet that contains the main logic of the distribution. RankifyGameMastersFacetFacet - Facet that contains the main logic of the distribution. RankifyInstanceGameOwnersFacet - Facet that contains the ownable logic of the distribution. (NB this will be deprecated) RankifyInstanceRequirementsFacet - Facet that contains the requirements logic of the distribution. If you have any further questions to clarify, please feel free to ask in the Rankify Discord .","title":"ACID distribution"},{"location":"architecture/create/","text":"Creating new MAO # In order to instantiate the MAO distribution, you don't need to deploy a thing. You just need to call the instantiate function of the the PeeramidLabsDistributor.sol contract and specify proper distribution Id and arguments. import { MAODistribution } from 'rankify-contracts/types'; const distributorArguments: MAODistribution.DistributorArgumentsStruct = { DAOSEttings: { daoURI: 'https://example.com/dao', subdomain: 'example', metadata: ethers.utils.hexlify(ethers.utils.toUtf8Bytes('metadata')), tokenName: 'tokenName', tokenSymbol: 'tokenSymbol', }, ACIDSettings: { RankTokenContractURI: 'https://example.com/rank', gamePrice: 1, joinGamePrice: 1, maxPlayersSize: 16, maxTurns: 1, metadata: ethers.utils.hexlify(ethers.utils.toUtf8Bytes('metadata')), minPlayersSize: 4, paymentToken: rankify.address, rankTokenURI: 'https://example.com/rank', timePerTurn: 1, timeToJoin: 1, voteCredits: 14, }, }; const data = ethers.utils.defaultAbiCoder.encode( [ 'tuple(tuple(string daoURI, string subdomain, bytes metadata, string tokenName, string tokenSymbol) DAOSEttings, tuple(uint256 timePerTurn, uint256 maxPlayersSize, uint256 minPlayersSize, uint256 timeToJoin, uint256 maxTurns, uint256 voteCredits, uint256 gamePrice, address paymentToken, uint256 joinGamePrice, string metadata, string rankTokenURI, string RankTokenContractURI) ACIDSettings)', ], [distributorArguments], ); const distributorsDistId = process.env.DISTRIBUTOR_DIST_ID; const tx = await distributorContract.instantiate(distributorsDistId, data); Getting DistributorsDistId # While in development, simplest way to get distributorsDistId for MAO distribution is to call getDistributions at PeeramidLabsDistributor contract and look for. It's likely to be only one. Note We will host a public API and upgrade our SDK to get the list of distributions soon.","title":"Creating new MAO"},{"location":"architecture/create/#creating-new-mao","text":"In order to instantiate the MAO distribution, you don't need to deploy a thing. You just need to call the instantiate function of the the PeeramidLabsDistributor.sol contract and specify proper distribution Id and arguments. import { MAODistribution } from 'rankify-contracts/types'; const distributorArguments: MAODistribution.DistributorArgumentsStruct = { DAOSEttings: { daoURI: 'https://example.com/dao', subdomain: 'example', metadata: ethers.utils.hexlify(ethers.utils.toUtf8Bytes('metadata')), tokenName: 'tokenName', tokenSymbol: 'tokenSymbol', }, ACIDSettings: { RankTokenContractURI: 'https://example.com/rank', gamePrice: 1, joinGamePrice: 1, maxPlayersSize: 16, maxTurns: 1, metadata: ethers.utils.hexlify(ethers.utils.toUtf8Bytes('metadata')), minPlayersSize: 4, paymentToken: rankify.address, rankTokenURI: 'https://example.com/rank', timePerTurn: 1, timeToJoin: 1, voteCredits: 14, }, }; const data = ethers.utils.defaultAbiCoder.encode( [ 'tuple(tuple(string daoURI, string subdomain, bytes metadata, string tokenName, string tokenSymbol) DAOSEttings, tuple(uint256 timePerTurn, uint256 maxPlayersSize, uint256 minPlayersSize, uint256 timeToJoin, uint256 maxTurns, uint256 voteCredits, uint256 gamePrice, address paymentToken, uint256 joinGamePrice, string metadata, string rankTokenURI, string RankTokenContractURI) ACIDSettings)', ], [distributorArguments], ); const distributorsDistId = process.env.DISTRIBUTOR_DIST_ID; const tx = await distributorContract.instantiate(distributorsDistId, data);","title":"Creating new MAO"},{"location":"architecture/create/#getting-distributorsdistid","text":"While in development, simplest way to get distributorsDistId for MAO distribution is to call getDistributions at PeeramidLabsDistributor contract and look for. It's likely to be only one. Note We will host a public API and upgrade our SDK to get the list of distributions soon.","title":"Getting DistributorsDistId"},{"location":"support/","text":"Community channels # Discord Telegram On X","title":"Community channels"},{"location":"support/#community-channels","text":"Discord Telegram On X","title":"Community channels"},{"location":"support/faq/","text":"Frequently asked questions #","title":"Frequently asked questions"},{"location":"support/faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"}]}