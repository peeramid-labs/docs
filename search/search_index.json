{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started # Project Overview # Rankify is a pioneering platform designed to transform organizational management through decentralized decision-making structures and AI-enhanced collaboration. By implementing the innovative Autonomous Competence Identification (ACID) protocol protocol, Rankify empowers organizations to streamline decision processes, improve accuracy, and achieve outcomes that rival those of expert systems. The success of this innovative approach hinges on the effective implementation of the ACID protocol, a milestone that promises to revolutionize the way organizations operate. Goals # Project goal is to create a fully autonomous on-chain system that is efficient and secure in it's decision making process. Ultimate goal is to create a organization management protocol that is neural-network like, fully decentralized and is represented by as diverse as possible, top level experts in their respective fields. Scope # The project is divided into several phases, each of which is designed to address a specific aspect of the ACID protocol. The first phase focuses on the development of the core infrastructure, including the creation of the Rankify DAO, the implementation of the ACID protocol, and the establishment of the Rankify ecosystem. Subsequent phases will focus on the development of additional features, such as the integration of AI-enhanced decision-making tools, the creation of a decentralized marketplace, and the implementation of MPC (Multi-Party Computation) based privacy solutions. Project ecosystem is EVM supported chains in the initial stages, with plans to expand to other chains in the future as well as support private chains that will be able to roll-up to public chains.","title":"Getting started"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#project-overview","text":"Rankify is a pioneering platform designed to transform organizational management through decentralized decision-making structures and AI-enhanced collaboration. By implementing the innovative Autonomous Competence Identification (ACID) protocol protocol, Rankify empowers organizations to streamline decision processes, improve accuracy, and achieve outcomes that rival those of expert systems. The success of this innovative approach hinges on the effective implementation of the ACID protocol, a milestone that promises to revolutionize the way organizations operate.","title":"Project Overview"},{"location":"#goals","text":"Project goal is to create a fully autonomous on-chain system that is efficient and secure in it's decision making process. Ultimate goal is to create a organization management protocol that is neural-network like, fully decentralized and is represented by as diverse as possible, top level experts in their respective fields.","title":"Goals"},{"location":"#scope","text":"The project is divided into several phases, each of which is designed to address a specific aspect of the ACID protocol. The first phase focuses on the development of the core infrastructure, including the creation of the Rankify DAO, the implementation of the ACID protocol, and the establishment of the Rankify ecosystem. Subsequent phases will focus on the development of additional features, such as the integration of AI-enhanced decision-making tools, the creation of a decentralized marketplace, and the implementation of MPC (Multi-Party Computation) based privacy solutions. Project ecosystem is EVM supported chains in the initial stages, with plans to expand to other chains in the future as well as support private chains that will be able to roll-up to public chains.","title":"Scope"},{"location":"governance/","text":"Governance # Rankify governance is Rankify itself. We are pioneering the way by starting from a multi party controlled wallet, that was seeded by Gitcoin grants and it will gradually evolve into interlinked autonomous organizations infrastructure network. Progressive decentralization # Definition of progressive decentralization is given as ability for the system to evolve from centralized to decentralized state. Rankify as protocol allows establishing Peer-to-Peer communications on Entity level without sacrificing for security. This is achieved by using Multisignature wallet that represents decentralized organization branches. Sub DAOs (Cells) # Sub DAOs, or also referred as Cells are autonomous bodies that can act on their own. Sub DAOs are specifically fetched to service some narrowed specialty need of the organization and represent faster, more specialized units that can take decisions more promptly, have required permissions available from parent DAO as well as they have ability to recursively repeat decentralization process, breaking it down to atomic pieces. Linkage between parent organization and Cells is done by having a \"tournament\", each of whose is a Rankify Application Sub DAO Tokenomics # Under a protocol, as DAO-cell creates new and new cells, it actually does not delegate any of control over itself other rather than that it is connected to it's sub-ordinate DAOs only via multi-sig wallet, which only may be controlling some of the sub-dao governance token issuance parameters as well as pre-definitions. Such sub-ordinates have no value on it own, they do not change any of the parent DAO governance parameters and they are not able to issue any of the governance tokens on their own either completely, or until some internal growth stage. There are no initial coin offerings available to such generated DAOs, instead ACID games are applied to generate such fully autonomously. Note In short, outcome of using the ACID protocol is that participants willing to become DAO members must enter a tournament, which will take their bets and mint award tokens to the winners. A sybil attack resistance as per ACID is expressed in contributions members must do in order to participate. Thus, a sybil attack analysis formula can be used to estimate equilibrium point between exchanging parent token directly versus exchanging it via sybil attack on children asset minting schema. Relation of these values can be estimated by sybil resistance of protocol, and in worst case is exponential: f(n) = C * N^n . Where f(n) is the value of the token, C is the constant, N is the quorum factor and n is the number of sub-dao governance votes obtained. Decentralization Roadmap # Approximate timeline is as follows: timeline section 2024 Q2 : Multisig Arbitrum Seeded Q3 : Arbitrum branch Governance token issuance : Rankify DAO (Arbitrum branch) Q4 : Base Multisig Seeded : Ranking Application (Arbitrum branch) section 2025 Q1 : Alpha participation Airdrop Q2+ : TBD More detail will be added as we flow through the process. Rankify Arbitrum Multisig # First Rankify DAO Multisig is deployed on the Arbitrum network, it's address is ToDo: Add Address Alpha DAO Arbitrum # Alpha DAO Arbitrum is a first decentralization step. Right now governance process undergoes in the community to define the details of the upcoming setup.","title":"Governance"},{"location":"governance/#governance","text":"Rankify governance is Rankify itself. We are pioneering the way by starting from a multi party controlled wallet, that was seeded by Gitcoin grants and it will gradually evolve into interlinked autonomous organizations infrastructure network.","title":"Governance"},{"location":"governance/#progressive-decentralization","text":"Definition of progressive decentralization is given as ability for the system to evolve from centralized to decentralized state. Rankify as protocol allows establishing Peer-to-Peer communications on Entity level without sacrificing for security. This is achieved by using Multisignature wallet that represents decentralized organization branches.","title":"Progressive decentralization"},{"location":"governance/#sub-daos-cells","text":"Sub DAOs, or also referred as Cells are autonomous bodies that can act on their own. Sub DAOs are specifically fetched to service some narrowed specialty need of the organization and represent faster, more specialized units that can take decisions more promptly, have required permissions available from parent DAO as well as they have ability to recursively repeat decentralization process, breaking it down to atomic pieces. Linkage between parent organization and Cells is done by having a \"tournament\", each of whose is a Rankify Application","title":"Sub DAOs (Cells)"},{"location":"governance/#sub-dao-tokenomics","text":"Under a protocol, as DAO-cell creates new and new cells, it actually does not delegate any of control over itself other rather than that it is connected to it's sub-ordinate DAOs only via multi-sig wallet, which only may be controlling some of the sub-dao governance token issuance parameters as well as pre-definitions. Such sub-ordinates have no value on it own, they do not change any of the parent DAO governance parameters and they are not able to issue any of the governance tokens on their own either completely, or until some internal growth stage. There are no initial coin offerings available to such generated DAOs, instead ACID games are applied to generate such fully autonomously. Note In short, outcome of using the ACID protocol is that participants willing to become DAO members must enter a tournament, which will take their bets and mint award tokens to the winners. A sybil attack resistance as per ACID is expressed in contributions members must do in order to participate. Thus, a sybil attack analysis formula can be used to estimate equilibrium point between exchanging parent token directly versus exchanging it via sybil attack on children asset minting schema. Relation of these values can be estimated by sybil resistance of protocol, and in worst case is exponential: f(n) = C * N^n . Where f(n) is the value of the token, C is the constant, N is the quorum factor and n is the number of sub-dao governance votes obtained.","title":"Sub DAO Tokenomics"},{"location":"governance/#decentralization-roadmap","text":"Approximate timeline is as follows: timeline section 2024 Q2 : Multisig Arbitrum Seeded Q3 : Arbitrum branch Governance token issuance : Rankify DAO (Arbitrum branch) Q4 : Base Multisig Seeded : Ranking Application (Arbitrum branch) section 2025 Q1 : Alpha participation Airdrop Q2+ : TBD More detail will be added as we flow through the process.","title":"Decentralization Roadmap"},{"location":"governance/#rankify-arbitrum-multisig","text":"First Rankify DAO Multisig is deployed on the Arbitrum network, it's address is ToDo: Add Address","title":"Rankify Arbitrum Multisig"},{"location":"governance/#alpha-dao-arbitrum","text":"Alpha DAO Arbitrum is a first decentralization step. Right now governance process undergoes in the community to define the details of the upcoming setup.","title":"Alpha DAO Arbitrum"},{"location":"tokens/","text":"Token types # Rank Token # Rank NFT is a semi fungible token that represents a competence. It is implemented as ERC1155 standard. It acts as a proof of competence that may be used in various scenarios as NFT itself, where token id represents bearers rank . These tokens are also may be exchanged for governance tokens under a deployment defined, immutable rules. Governance tokens # Governance token is a token that represents a voting power in the DAO. It is implemented as ERC20 standard. It is used to vote on proposals and to participate in the governance of the DAO. RKFY # RKFY is a governance token of the Rankify DAO. Its unique aspect is that it is bootstrapped solely by participating in the ranking games. There will be no ICO nor any other form of direct issuance of RKFY tokens except for the genesis ranking games. The games however are specifically tailored and will represent a real hands-on challenges organization will face, such as code development, community building and so on. Note You can think of such distribution system as a \"proof of useful work\" airdrop for the DAO. \"RANKIFY CORE\" NFT # \"RANKIFY CORE\" NFT is a special NFT that is minted to the DAO members that have participated in the genesis ranking games. It is is exchanged on fixed ratio tied to token Id. It is used to represent the DAO membership and to provide additional benefits to the members.","title":"Token types"},{"location":"tokens/#token-types","text":"","title":"Token types"},{"location":"tokens/#rank-token","text":"Rank NFT is a semi fungible token that represents a competence. It is implemented as ERC1155 standard. It acts as a proof of competence that may be used in various scenarios as NFT itself, where token id represents bearers rank . These tokens are also may be exchanged for governance tokens under a deployment defined, immutable rules.","title":"Rank Token"},{"location":"tokens/#governance-tokens","text":"Governance token is a token that represents a voting power in the DAO. It is implemented as ERC20 standard. It is used to vote on proposals and to participate in the governance of the DAO.","title":"Governance tokens"},{"location":"tokens/#rkfy","text":"RKFY is a governance token of the Rankify DAO. Its unique aspect is that it is bootstrapped solely by participating in the ranking games. There will be no ICO nor any other form of direct issuance of RKFY tokens except for the genesis ranking games. The games however are specifically tailored and will represent a real hands-on challenges organization will face, such as code development, community building and so on. Note You can think of such distribution system as a \"proof of useful work\" airdrop for the DAO.","title":"RKFY"},{"location":"tokens/#rankify-core-nft","text":"\"RANKIFY CORE\" NFT is a special NFT that is minted to the DAO members that have participated in the genesis ranking games. It is is exchanged on fixed ratio tied to token Id. It is used to represent the DAO membership and to provide additional benefits to the members.","title":"\"RANKIFY CORE\" NFT"},{"location":"Ethereum%20Distribution%20System/IDistribution/","text":"IDistribution # Interface for distribution-related functionalities. It can get sources and produce a new instances out from them. It also provides metadata about the distribution. Notice It is highly recommended to keep implementation stateless, and use immutable variables for any state. This allows your code to be referred in distributor and respositories via ERC7744. It's also easier to reason about, and more gas efficient. Distributed # Emitted when a distribution occurs. event Distributed ( address distributor , address [] instances ) Input Type Description distributor address The address of the entity that performed the distribution. instances address[] An array of addresses that were produced. instantiate # Instantiates a new instance with the given parameters. function instantiate ( bytes data ) external returns ( address [] instances , bytes32 distributionName , uint256 distributionVersion ) Input Type Description data bytes The data to be used for instantiation. Output instances address[] An array of addresses that were produced. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. Warning It MUST emit Distributed event. get # Retrieves the current distribution sources. function get () external view returns ( address [] sources , bytes32 distributionName , uint256 distributionVersion ) Output Type Description sources address[] An array of addresses that are used for instantiation. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. getMetadata # function getMetadata () external view returns ( string )","title":"IDistribution"},{"location":"Ethereum%20Distribution%20System/IDistribution/#idistribution","text":"Interface for distribution-related functionalities. It can get sources and produce a new instances out from them. It also provides metadata about the distribution. Notice It is highly recommended to keep implementation stateless, and use immutable variables for any state. This allows your code to be referred in distributor and respositories via ERC7744. It's also easier to reason about, and more gas efficient.","title":"IDistribution"},{"location":"Ethereum%20Distribution%20System/IDistribution/#distributed","text":"Emitted when a distribution occurs. event Distributed ( address distributor , address [] instances ) Input Type Description distributor address The address of the entity that performed the distribution. instances address[] An array of addresses that were produced.","title":"Distributed"},{"location":"Ethereum%20Distribution%20System/IDistribution/#instantiate","text":"Instantiates a new instance with the given parameters. function instantiate ( bytes data ) external returns ( address [] instances , bytes32 distributionName , uint256 distributionVersion ) Input Type Description data bytes The data to be used for instantiation. Output instances address[] An array of addresses that were produced. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. Warning It MUST emit Distributed event.","title":"instantiate"},{"location":"Ethereum%20Distribution%20System/IDistribution/#get","text":"Retrieves the current distribution sources. function get () external view returns ( address [] sources , bytes32 distributionName , uint256 distributionVersion ) Output Type Description sources address[] An array of addresses that are used for instantiation. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution.","title":"get"},{"location":"Ethereum%20Distribution%20System/IDistribution/#getmetadata","text":"function getMetadata () external view returns ( string )","title":"getMetadata"},{"location":"Ethereum%20Distribution%20System/IDistributor/","text":"IDistributor Interface # Defines the standard functions for a distributor contract. Notice If you want to use IRepository for versioned distributions, use IVersionDistributor interface. DistributionNotFound # Error indicating that the distribution with the specified ID was not found. error DistributionNotFound ( bytes32 id ) Input Type Description id bytes32 The unique identifier of the distribution that was not found. DistributionExists # Error indicating that a distribution with the specified ID already exists. error DistributionExists ( bytes32 id ) Input Type Description id bytes32 The unique identifier of the distribution that already exists. InitializerNotFound # Error indicating that the initializer for the distribution was not found. error InitializerNotFound ( bytes32 id ) Input Type Description id bytes32 The unique identifier of the distribution that was not found. InvalidInstance # Error indicating that the instance is invalid. error InvalidInstance ( address instance ) Input Type Description instance address The address of the instance that is considered invalid. Instantiated # Event emitted when a new distribution is instantiated. event Instantiated ( bytes32 distributionId , uint256 instanceId , bytes argsHash , address [] instances ) Input Type Description distributionId bytes32 The unique identifier of the distribution. instanceId uint256 The unique identifier of the instance. argsHash bytes The hash of the arguments used to instantiate the distribution. instances address[] The addresses of the instances that were created. Notice It MUST emit when IDistributor#instantiate is called. DistributionRemoved # Event emitted when a distribution is removed. event DistributionRemoved ( bytes32 id ) Input Type Description id bytes32 The unique identifier of the distribution that was removed. Notice It MUST emit when IDistributor#removedistribution is called. DistributionAdded # Event emitted when a distribution is added. event DistributionAdded ( bytes32 id , address initializer ) Input Type Description id bytes32 The unique identifier of the distribution that was added. initializer address The address of the initializer that was added. Notice It MUST emit when IDistributor#adddistribution is called. getDistributions # Retrieves the unique identifiers of all distributions. function getDistributions () external view returns ( bytes32 [] distributorIds ) Output Type Description distributorIds bytes32[] An array of unique identifiers of all distributions. getDistributionURI # Retrieves the URI of the distribution. function getDistributionURI ( bytes32 distributorId ) external view returns ( string ) Input Type Description distributorId bytes32 The unique identifier of the distribution. Output 0 string uri The URI of the distribution. instantiate # Instantiates a new instance with the given distributor ID and arguments. function instantiate ( bytes32 distributorId , bytes args ) external returns ( address [], bytes32 distributionName , uint256 distributionVersion ) Input Type Description distributorId bytes32 The unique identifier of the distributor. args bytes The arguments to be used for instantiation. Output 0 address[] instances The addresses of the instances that were created. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. Notice It MUST emit Instantiated event. addDistribution # function addDistribution ( bytes32 distributorId , address initializer ) external removeDistribution # function removeDistribution ( bytes32 distributorId ) external getDistributionId # function getDistributionId ( address instance ) external view returns ( bytes32 ) getInstanceId # function getInstanceId ( address instance ) external view returns ( uint256 )","title":"IDistributor Interface"},{"location":"Ethereum%20Distribution%20System/IDistributor/#idistributor-interface","text":"Defines the standard functions for a distributor contract. Notice If you want to use IRepository for versioned distributions, use IVersionDistributor interface.","title":"IDistributor Interface"},{"location":"Ethereum%20Distribution%20System/IDistributor/#distributionnotfound","text":"Error indicating that the distribution with the specified ID was not found. error DistributionNotFound ( bytes32 id ) Input Type Description id bytes32 The unique identifier of the distribution that was not found.","title":"DistributionNotFound"},{"location":"Ethereum%20Distribution%20System/IDistributor/#distributionexists","text":"Error indicating that a distribution with the specified ID already exists. error DistributionExists ( bytes32 id ) Input Type Description id bytes32 The unique identifier of the distribution that already exists.","title":"DistributionExists"},{"location":"Ethereum%20Distribution%20System/IDistributor/#initializernotfound","text":"Error indicating that the initializer for the distribution was not found. error InitializerNotFound ( bytes32 id ) Input Type Description id bytes32 The unique identifier of the distribution that was not found.","title":"InitializerNotFound"},{"location":"Ethereum%20Distribution%20System/IDistributor/#invalidinstance","text":"Error indicating that the instance is invalid. error InvalidInstance ( address instance ) Input Type Description instance address The address of the instance that is considered invalid.","title":"InvalidInstance"},{"location":"Ethereum%20Distribution%20System/IDistributor/#instantiated","text":"Event emitted when a new distribution is instantiated. event Instantiated ( bytes32 distributionId , uint256 instanceId , bytes argsHash , address [] instances ) Input Type Description distributionId bytes32 The unique identifier of the distribution. instanceId uint256 The unique identifier of the instance. argsHash bytes The hash of the arguments used to instantiate the distribution. instances address[] The addresses of the instances that were created. Notice It MUST emit when IDistributor#instantiate is called.","title":"Instantiated"},{"location":"Ethereum%20Distribution%20System/IDistributor/#distributionremoved","text":"Event emitted when a distribution is removed. event DistributionRemoved ( bytes32 id ) Input Type Description id bytes32 The unique identifier of the distribution that was removed. Notice It MUST emit when IDistributor#removedistribution is called.","title":"DistributionRemoved"},{"location":"Ethereum%20Distribution%20System/IDistributor/#distributionadded","text":"Event emitted when a distribution is added. event DistributionAdded ( bytes32 id , address initializer ) Input Type Description id bytes32 The unique identifier of the distribution that was added. initializer address The address of the initializer that was added. Notice It MUST emit when IDistributor#adddistribution is called.","title":"DistributionAdded"},{"location":"Ethereum%20Distribution%20System/IDistributor/#getdistributions","text":"Retrieves the unique identifiers of all distributions. function getDistributions () external view returns ( bytes32 [] distributorIds ) Output Type Description distributorIds bytes32[] An array of unique identifiers of all distributions.","title":"getDistributions"},{"location":"Ethereum%20Distribution%20System/IDistributor/#getdistributionuri","text":"Retrieves the URI of the distribution. function getDistributionURI ( bytes32 distributorId ) external view returns ( string ) Input Type Description distributorId bytes32 The unique identifier of the distribution. Output 0 string uri The URI of the distribution.","title":"getDistributionURI"},{"location":"Ethereum%20Distribution%20System/IDistributor/#instantiate","text":"Instantiates a new instance with the given distributor ID and arguments. function instantiate ( bytes32 distributorId , bytes args ) external returns ( address [], bytes32 distributionName , uint256 distributionVersion ) Input Type Description distributorId bytes32 The unique identifier of the distributor. args bytes The arguments to be used for instantiation. Output 0 address[] instances The addresses of the instances that were created. distributionName bytes32 The name of the distribution. distributionVersion uint256 The version of the distribution. Notice It MUST emit Instantiated event.","title":"instantiate"},{"location":"Ethereum%20Distribution%20System/IDistributor/#adddistribution","text":"function addDistribution ( bytes32 distributorId , address initializer ) external","title":"addDistribution"},{"location":"Ethereum%20Distribution%20System/IDistributor/#removedistribution","text":"function removeDistribution ( bytes32 distributorId ) external","title":"removeDistribution"},{"location":"Ethereum%20Distribution%20System/IDistributor/#getdistributionid","text":"function getDistributionId ( address instance ) external view returns ( bytes32 )","title":"getDistributionId"},{"location":"Ethereum%20Distribution%20System/IDistributor/#getinstanceid","text":"function getInstanceId ( address instance ) external view returns ( uint256 )","title":"getInstanceId"},{"location":"Ethereum%20Distribution%20System/IERC7746/","text":"IERC7746 Interface # Notice Interface for the ERC7746 standard. beforeCall # Validates a function call before execution. function beforeCall ( bytes configuration , bytes4 selector , address sender , uint256 value , bytes data ) external returns ( bytes ) Input Type Description configuration bytes Middleware-specific configuration data. selector bytes4 The function selector being called. sender address The address initiating the call. value uint256 The amount of ETH sent with the call (if any). data bytes The calldata for the function call. Output 0 bytes beforeCallResult Arbitrary data to be passed to afterCallValidation . Notice MUST revert if validation fails. afterCall # Validates a function call after execution. function afterCall ( bytes configuration , bytes4 selector , address sender , uint256 value , bytes data , bytes beforeCallResult ) external Input Type Description configuration bytes Middleware-specific configuration data. selector bytes4 The function selector being called. sender address The address initiating the call. value uint256 The amount of ETH sent with the call (if any). data bytes The calldata for the function call. beforeCallResult bytes The data returned by beforeCallValidation . Notice MUST revert if validation fails.","title":"IERC7746 Interface"},{"location":"Ethereum%20Distribution%20System/IERC7746/#ierc7746-interface","text":"Notice Interface for the ERC7746 standard.","title":"IERC7746 Interface"},{"location":"Ethereum%20Distribution%20System/IERC7746/#beforecall","text":"Validates a function call before execution. function beforeCall ( bytes configuration , bytes4 selector , address sender , uint256 value , bytes data ) external returns ( bytes ) Input Type Description configuration bytes Middleware-specific configuration data. selector bytes4 The function selector being called. sender address The address initiating the call. value uint256 The amount of ETH sent with the call (if any). data bytes The calldata for the function call. Output 0 bytes beforeCallResult Arbitrary data to be passed to afterCallValidation . Notice MUST revert if validation fails.","title":"beforeCall"},{"location":"Ethereum%20Distribution%20System/IERC7746/#aftercall","text":"Validates a function call after execution. function afterCall ( bytes configuration , bytes4 selector , address sender , uint256 value , bytes data , bytes beforeCallResult ) external Input Type Description configuration bytes Middleware-specific configuration data. selector bytes4 The function selector being called. sender address The address initiating the call. value uint256 The amount of ETH sent with the call (if any). data bytes The calldata for the function call. beforeCallResult bytes The data returned by beforeCallValidation . Notice MUST revert if validation fails.","title":"afterCall"},{"location":"Ethereum%20Distribution%20System/IInitializer/","text":"IInitializer # Interface for the Initializer contract. This is intended to be used as distribution initializer within the Distributor contract. Initialized # event Initialized ( address container , bytes32 codeHash ) initializationFailed # error initializationFailed ( bytes32 id , string reason ) initialize # Initializes the contract with necessary parameters. function initialize ( bytes32 distributionId , address [] instances , bytes32 distributionName , uint256 distributionVersion , bytes args ) external Input Type Description distributionId bytes32 The ID of the distribution being initialized instances address[] The addresses of the instances being initialized distributionName bytes32 The name of the distribution distributionVersion uint256 The version of the distribution args bytes The additional arguments to be used for initialization Notice This function should be delegete-called by the distributor contract.","title":"IInitializer"},{"location":"Ethereum%20Distribution%20System/IInitializer/#iinitializer","text":"Interface for the Initializer contract. This is intended to be used as distribution initializer within the Distributor contract.","title":"IInitializer"},{"location":"Ethereum%20Distribution%20System/IInitializer/#initialized","text":"event Initialized ( address container , bytes32 codeHash )","title":"Initialized"},{"location":"Ethereum%20Distribution%20System/IInitializer/#initializationfailed","text":"error initializationFailed ( bytes32 id , string reason )","title":"initializationFailed"},{"location":"Ethereum%20Distribution%20System/IInitializer/#initialize","text":"Initializes the contract with necessary parameters. function initialize ( bytes32 distributionId , address [] instances , bytes32 distributionName , uint256 distributionVersion , bytes args ) external Input Type Description distributionId bytes32 The ID of the distribution being initialized instances address[] The addresses of the instances being initialized distributionName bytes32 The name of the distribution distributionVersion uint256 The version of the distribution args bytes The additional arguments to be used for initialization Notice This function should be delegete-called by the distributor contract.","title":"initialize"},{"location":"Ethereum%20Distribution%20System/IInstaller/","text":"IInstaller Interface # Enables target smart account to interact with Distributor contract ecosystem. NotAnInstance # error NotAnInstance ( address instance ) Input Type Description instance address The address that was checked and found not to be an instance. Notice Error indicating that the provided address is not a valid instance. InvalidDistributor # Error indicating that the provided distributor is invalid. error InvalidDistributor ( contract IDistributor distributor ) Input Type Description distributor contract IDistributor The distributor that is considered invalid. InvalidTarget # error InvalidTarget ( address target ) Input Type Description target address The address that is considered invalid. Notice Error indicating that the provided target address is not the smart account installer serves. alreadyAllowed # Error indicating that the specified distributor is already allowed. error alreadyAllowed ( contract IDistributor distributor ) Input Type Description distributor contract IDistributor The distributor that is already allowed. DistributionIsNotPermitted # Error indicating that a distribution is not permitted (not installed). error DistributionIsNotPermitted ( contract IDistributor distributor , bytes32 distributionId ) Input Type Description distributor contract IDistributor The address of the distributor containing the distribution. distributionId bytes32 The unique identifier of the distribution. DissalowDistOnWhitelistedDistributor # Error indicating that distributor is whitelisted and hence it is not possible to selectively dissalow distriributions. error DissalowDistOnWhitelistedDistributor ( contract IDistributor distributor , bytes32 distributionId ) Input Type Description distributor contract IDistributor The whitelisted distributor. distributionId bytes32 The ID of the distribution that was attempted to dissalow. Notice If getting this error: consider first removing distributor from whitelist, and then dissalowing the distribution. DistributorWhitelisted # event DistributorWhitelisted ( contract IDistributor distributor ) Input Type Description distributor contract IDistributor The address of the distributor that has been whitelisted. Notice Emitted when a distributor is whitelisted. Any distribution of the whitelisted distributor MUST be allowed to be installed. DistributorWhitelistRevoked # Emitted when a distributor is removed from the whitelist. event DistributorWhitelistRevoked ( contract IDistributor distributor ) Input Type Description distributor contract IDistributor The address of the distributor that was revoked. Warning After removal, the distributions that were allowed by id are still allowed. DistributionAllowed # event DistributionAllowed ( contract IDistributor distributor , bytes32 distributionId ) Input Type Description distributor contract IDistributor The address of the distributor that is allowed. distributionId bytes32 The unique identifier of the distribution. Notice Emitted when a distribution is allowed by the installer. DistributionDisallowed # event DistributionDisallowed ( contract IDistributor distributor , bytes32 distributionId ) Input Type Description distributor contract IDistributor The address of the distributor that is disallowed. distributionId bytes32 The unique identifier of the distribution that is disallowed. Notice Emitted when a distribution is disallowed by the installer. allowDistribution # Allows a specified distributor to distribute a given distribution ID. function allowDistribution ( contract IDistributor distributor , bytes32 distributionId ) external Input Type Description distributor contract IDistributor The address of the distributor hosting a distribution Id. distributionId bytes32 The ID of the distribution to be allowed. Notice MUST emit DistributionAllowed event. disallowDistribution # Disallows a specific distribution from a given distributor. function disallowDistribution ( contract IDistributor distributor , bytes32 distributionId ) external Input Type Description distributor contract IDistributor The address of the distributor contract. distributionId bytes32 The unique identifier of the distribution to be disallowed. Notice MUST emit DistributionDisallowed event. whitelistedDistributions # Retrieves the list of whitelisted distributions for a given distributor. function whitelistedDistributions ( contract IDistributor distributor ) external view returns ( bytes32 []) Input Type Description distributor contract IDistributor The address of the distributor to query. Output 0 bytes32[] An array of bytes32 representing the whitelisted distributions. Notice If the distributor is whitelisted, all distributions are allowed. whitelistDistributor # Adds a distributor to the whitelist. function whitelistDistributor ( contract IDistributor distributor ) external Input Type Description distributor contract IDistributor The address of the distributor to be whitelisted. Notice After whitelisting, all distributions of the distributor are allowed. Must emit DistributorWhitelisted event. revokeWhitelistedDistributor # Revokes the whitelisted status of a given distributor. function revokeWhitelistedDistributor ( contract IDistributor distributor ) external Input Type Description distributor contract IDistributor The address of the distributor to be revoked. Notice After revoking, the distributions that were allowed by id are still allowed. Must emit DistributorWhitelistRevoked event. isDistributor # Checks if the given address is a valid distributor. function isDistributor ( contract IDistributor distributor ) external view returns ( bool ) Input Type Description distributor contract IDistributor The address of the distributor to check. Output 0 bool bool Returns true if the address is a valid distributor, otherwise false. getWhitelistedDistributors # Retrieves the list of whitelisted distributor addresses. function getWhitelistedDistributors () external view returns ( address []) Output Type Description 0 address[] An array of addresses that are whitelisted as distributors. Installed # event Installed ( address instance , bytes32 distributionId , bytes32 permissions , bytes args ) Input Type Description instance address The address of the installed instance. distributionId bytes32 The identifier of the distribution. permissions bytes32 The permissions associated with the installation. args bytes Additional arguments related to the installation. Notice Emitted when an instance is installed. MUST be emitted for every new instance installed via install function. Uninstalled # event Uninstalled ( address instance ) install # Installs a new instance with the given distributor, distribution ID, and arguments. function install ( contract IDistributor distributor , bytes32 distributionId , bytes args ) external payable returns ( uint256 instanceId ) Input Type Description distributor contract IDistributor The distributor contract to be used for the installation. distributionId bytes32 The unique identifier for the distribution. args bytes Additional arguments required for the installation process. Output instanceId uint256 The unique identifier of the newly installed instance. Notice MUST emit Installed event per installed instance. MUST revert if the distributor is not whitelisted or the distribution is not allowed. MUST revert if the distributor is not a valid distributor. After succesfull installation ERC77446 hooks SHALL NOT revert if called by target, specifying active instance in sender field. uninstall # Uninstalls an instance with the given ID. function uninstall ( uint256 instanceId ) external Input Type Description instanceId uint256 The unique identifier of the instance to be uninstalled. Notice MUST emit Uninstalled event per uninstalled instance. MUST revert if the instance is not installed. After succesfull uninstallation ERC77446 hooks SHALL revert if called by target, specifying uninstalled instance in sender field. getInstance # Retrieves the contracts associated with a specific instance. function getInstance ( uint256 instanceId ) external view returns ( address [] instaneContracts ) Input Type Description instanceId uint256 The unique identifier of the instance. Output instaneContracts address[] An array of addresses representing the contracts of the instance. getInstancesNum # Retrieves the number of instances. function getInstancesNum () external view returns ( uint256 ) Output Type Description 0 uint256 The total number of instances as a uint256. Notice this number SHALL NOT decrease after uninstallation. isInstance # Checks if the given address is an active instance. function isInstance ( address instance ) external view returns ( bool ) Input Type Description instance address The address to check. Output 0 bool bool True if the address is an instance, false otherwise. distributorOf # Returns the distributor associated with a given instance. function distributorOf ( address instance ) external view returns ( contract IDistributor ) Input Type Description instance address The address of the instance for which the distributor is being queried. Output 0 contract IDistributor The distributor associated with the specified instance. target # Retrieves the address of the target contract. function target () external view returns ( address ) Output Type Description 0 address The address of the target contract.","title":"IInstaller Interface"},{"location":"Ethereum%20Distribution%20System/IInstaller/#iinstaller-interface","text":"Enables target smart account to interact with Distributor contract ecosystem.","title":"IInstaller Interface"},{"location":"Ethereum%20Distribution%20System/IInstaller/#notaninstance","text":"error NotAnInstance ( address instance ) Input Type Description instance address The address that was checked and found not to be an instance. Notice Error indicating that the provided address is not a valid instance.","title":"NotAnInstance"},{"location":"Ethereum%20Distribution%20System/IInstaller/#invaliddistributor","text":"Error indicating that the provided distributor is invalid. error InvalidDistributor ( contract IDistributor distributor ) Input Type Description distributor contract IDistributor The distributor that is considered invalid.","title":"InvalidDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#invalidtarget","text":"error InvalidTarget ( address target ) Input Type Description target address The address that is considered invalid. Notice Error indicating that the provided target address is not the smart account installer serves.","title":"InvalidTarget"},{"location":"Ethereum%20Distribution%20System/IInstaller/#alreadyallowed","text":"Error indicating that the specified distributor is already allowed. error alreadyAllowed ( contract IDistributor distributor ) Input Type Description distributor contract IDistributor The distributor that is already allowed.","title":"alreadyAllowed"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributionisnotpermitted","text":"Error indicating that a distribution is not permitted (not installed). error DistributionIsNotPermitted ( contract IDistributor distributor , bytes32 distributionId ) Input Type Description distributor contract IDistributor The address of the distributor containing the distribution. distributionId bytes32 The unique identifier of the distribution.","title":"DistributionIsNotPermitted"},{"location":"Ethereum%20Distribution%20System/IInstaller/#dissalowdistonwhitelisteddistributor","text":"Error indicating that distributor is whitelisted and hence it is not possible to selectively dissalow distriributions. error DissalowDistOnWhitelistedDistributor ( contract IDistributor distributor , bytes32 distributionId ) Input Type Description distributor contract IDistributor The whitelisted distributor. distributionId bytes32 The ID of the distribution that was attempted to dissalow. Notice If getting this error: consider first removing distributor from whitelist, and then dissalowing the distribution.","title":"DissalowDistOnWhitelistedDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributorwhitelisted","text":"event DistributorWhitelisted ( contract IDistributor distributor ) Input Type Description distributor contract IDistributor The address of the distributor that has been whitelisted. Notice Emitted when a distributor is whitelisted. Any distribution of the whitelisted distributor MUST be allowed to be installed.","title":"DistributorWhitelisted"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributorwhitelistrevoked","text":"Emitted when a distributor is removed from the whitelist. event DistributorWhitelistRevoked ( contract IDistributor distributor ) Input Type Description distributor contract IDistributor The address of the distributor that was revoked. Warning After removal, the distributions that were allowed by id are still allowed.","title":"DistributorWhitelistRevoked"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributionallowed","text":"event DistributionAllowed ( contract IDistributor distributor , bytes32 distributionId ) Input Type Description distributor contract IDistributor The address of the distributor that is allowed. distributionId bytes32 The unique identifier of the distribution. Notice Emitted when a distribution is allowed by the installer.","title":"DistributionAllowed"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributiondisallowed","text":"event DistributionDisallowed ( contract IDistributor distributor , bytes32 distributionId ) Input Type Description distributor contract IDistributor The address of the distributor that is disallowed. distributionId bytes32 The unique identifier of the distribution that is disallowed. Notice Emitted when a distribution is disallowed by the installer.","title":"DistributionDisallowed"},{"location":"Ethereum%20Distribution%20System/IInstaller/#allowdistribution","text":"Allows a specified distributor to distribute a given distribution ID. function allowDistribution ( contract IDistributor distributor , bytes32 distributionId ) external Input Type Description distributor contract IDistributor The address of the distributor hosting a distribution Id. distributionId bytes32 The ID of the distribution to be allowed. Notice MUST emit DistributionAllowed event.","title":"allowDistribution"},{"location":"Ethereum%20Distribution%20System/IInstaller/#disallowdistribution","text":"Disallows a specific distribution from a given distributor. function disallowDistribution ( contract IDistributor distributor , bytes32 distributionId ) external Input Type Description distributor contract IDistributor The address of the distributor contract. distributionId bytes32 The unique identifier of the distribution to be disallowed. Notice MUST emit DistributionDisallowed event.","title":"disallowDistribution"},{"location":"Ethereum%20Distribution%20System/IInstaller/#whitelisteddistributions","text":"Retrieves the list of whitelisted distributions for a given distributor. function whitelistedDistributions ( contract IDistributor distributor ) external view returns ( bytes32 []) Input Type Description distributor contract IDistributor The address of the distributor to query. Output 0 bytes32[] An array of bytes32 representing the whitelisted distributions. Notice If the distributor is whitelisted, all distributions are allowed.","title":"whitelistedDistributions"},{"location":"Ethereum%20Distribution%20System/IInstaller/#whitelistdistributor","text":"Adds a distributor to the whitelist. function whitelistDistributor ( contract IDistributor distributor ) external Input Type Description distributor contract IDistributor The address of the distributor to be whitelisted. Notice After whitelisting, all distributions of the distributor are allowed. Must emit DistributorWhitelisted event.","title":"whitelistDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#revokewhitelisteddistributor","text":"Revokes the whitelisted status of a given distributor. function revokeWhitelistedDistributor ( contract IDistributor distributor ) external Input Type Description distributor contract IDistributor The address of the distributor to be revoked. Notice After revoking, the distributions that were allowed by id are still allowed. Must emit DistributorWhitelistRevoked event.","title":"revokeWhitelistedDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#isdistributor","text":"Checks if the given address is a valid distributor. function isDistributor ( contract IDistributor distributor ) external view returns ( bool ) Input Type Description distributor contract IDistributor The address of the distributor to check. Output 0 bool bool Returns true if the address is a valid distributor, otherwise false.","title":"isDistributor"},{"location":"Ethereum%20Distribution%20System/IInstaller/#getwhitelisteddistributors","text":"Retrieves the list of whitelisted distributor addresses. function getWhitelistedDistributors () external view returns ( address []) Output Type Description 0 address[] An array of addresses that are whitelisted as distributors.","title":"getWhitelistedDistributors"},{"location":"Ethereum%20Distribution%20System/IInstaller/#installed","text":"event Installed ( address instance , bytes32 distributionId , bytes32 permissions , bytes args ) Input Type Description instance address The address of the installed instance. distributionId bytes32 The identifier of the distribution. permissions bytes32 The permissions associated with the installation. args bytes Additional arguments related to the installation. Notice Emitted when an instance is installed. MUST be emitted for every new instance installed via install function.","title":"Installed"},{"location":"Ethereum%20Distribution%20System/IInstaller/#uninstalled","text":"event Uninstalled ( address instance )","title":"Uninstalled"},{"location":"Ethereum%20Distribution%20System/IInstaller/#install","text":"Installs a new instance with the given distributor, distribution ID, and arguments. function install ( contract IDistributor distributor , bytes32 distributionId , bytes args ) external payable returns ( uint256 instanceId ) Input Type Description distributor contract IDistributor The distributor contract to be used for the installation. distributionId bytes32 The unique identifier for the distribution. args bytes Additional arguments required for the installation process. Output instanceId uint256 The unique identifier of the newly installed instance. Notice MUST emit Installed event per installed instance. MUST revert if the distributor is not whitelisted or the distribution is not allowed. MUST revert if the distributor is not a valid distributor. After succesfull installation ERC77446 hooks SHALL NOT revert if called by target, specifying active instance in sender field.","title":"install"},{"location":"Ethereum%20Distribution%20System/IInstaller/#uninstall","text":"Uninstalls an instance with the given ID. function uninstall ( uint256 instanceId ) external Input Type Description instanceId uint256 The unique identifier of the instance to be uninstalled. Notice MUST emit Uninstalled event per uninstalled instance. MUST revert if the instance is not installed. After succesfull uninstallation ERC77446 hooks SHALL revert if called by target, specifying uninstalled instance in sender field.","title":"uninstall"},{"location":"Ethereum%20Distribution%20System/IInstaller/#getinstance","text":"Retrieves the contracts associated with a specific instance. function getInstance ( uint256 instanceId ) external view returns ( address [] instaneContracts ) Input Type Description instanceId uint256 The unique identifier of the instance. Output instaneContracts address[] An array of addresses representing the contracts of the instance.","title":"getInstance"},{"location":"Ethereum%20Distribution%20System/IInstaller/#getinstancesnum","text":"Retrieves the number of instances. function getInstancesNum () external view returns ( uint256 ) Output Type Description 0 uint256 The total number of instances as a uint256. Notice this number SHALL NOT decrease after uninstallation.","title":"getInstancesNum"},{"location":"Ethereum%20Distribution%20System/IInstaller/#isinstance","text":"Checks if the given address is an active instance. function isInstance ( address instance ) external view returns ( bool ) Input Type Description instance address The address to check. Output 0 bool bool True if the address is an instance, false otherwise.","title":"isInstance"},{"location":"Ethereum%20Distribution%20System/IInstaller/#distributorof","text":"Returns the distributor associated with a given instance. function distributorOf ( address instance ) external view returns ( contract IDistributor ) Input Type Description instance address The address of the instance for which the distributor is being queried. Output 0 contract IDistributor The distributor associated with the specified instance.","title":"distributorOf"},{"location":"Ethereum%20Distribution%20System/IInstaller/#target","text":"Retrieves the address of the target contract. function target () external view returns ( address ) Output Type Description 0 address The address of the target contract.","title":"target"},{"location":"Ethereum%20Distribution%20System/IRepository/","text":"IRepository Interface # It is intended to be implemented by contracts that manage a collection of versions of a byte code. Source # Represents a source with version information, a unique identifier, and associated metadata. Input Type Description struct Source { struct LibSemver . Version version ; bytes32 sourceId ; bytes metadata ; } VersionDoesNotExist # Error indicating that the specified version does not exist. error VersionDoesNotExist ( uint256 version ) Input Type Description version uint256 The version number that does not exist. ReleaseZeroNotAllowed # Error indicating that a release with a zero value is not allowed. error ReleaseZeroNotAllowed () VersionExists # Error indicating that the specified version already exists. error VersionExists ( uint256 version ) Input Type Description version uint256 The version number that already exists. VersionIncrementInvalid # Error indicating that the version increment is invalid. error VersionIncrementInvalid ( uint256 version ) Input Type Description version uint256 The version number that caused the error. Notice The version increment must be exactly one for either major, minor, or patch. EmptyReleaseMetadata # error EmptyReleaseMetadata () Notice Error indicating that the release metadata is empty. VersionAdded # Emitted when a new version is added to the repository. event VersionAdded ( uint256 version , bytes32 source , bytes buildMetadata ) Input Type Description version uint256 The version number of the added item. source bytes32 The source identifier of the added item. buildMetadata bytes Additional metadata related to the build. ReleaseMetadataUpdated # Emitted when the metadata of a release is updated. event ReleaseMetadataUpdated ( uint256 version , bytes releaseMetadata ) Input Type Description version uint256 The version number of the release. releaseMetadata bytes The metadata associated with the release. updateReleaseMetadata # Updates the metadata for a specific release version. function updateReleaseMetadata ( struct LibSemver . Version version , bytes releaseMetadata ) external Input Type Description version struct LibSemver.Version The version of the release to update. releaseMetadata bytes The new metadata to associate with the release. Notice It MUST emit ReleaseMetadataUpdated event. repositoryName # Retrieves the name of the repository. function repositoryName () external view returns ( bytes32 ) Output Type Description 0 bytes32 The name of the repository as a bytes32 value. newRelease # Creates a new release for the given source ID. function newRelease ( bytes32 sourceId , bytes metadata , struct LibSemver . Version version ) external Input Type Description sourceId bytes32 The unique identifier of the source. metadata bytes The metadata associated with the release. version struct LibSemver.Version The semantic version of the new release. Notice It MUST emit VersionAdded event. getLatest # Retrieves the latest source. function getLatest () external view returns ( struct IRepository . Source ) Output Type Description 0 struct IRepository.Source The requested source get # Retrieves a specific item from the repository. function get ( struct LibSemver . Version baseVersion , enum LibSemver . requirements requirement ) external view returns ( struct IRepository . Source ) Input Type Description baseVersion struct LibSemver.Version the base of required version requirement enum LibSemver.requirements the requirement of the version Output 0 struct IRepository.Source The requested Source .","title":"IRepository Interface"},{"location":"Ethereum%20Distribution%20System/IRepository/#irepository-interface","text":"It is intended to be implemented by contracts that manage a collection of versions of a byte code.","title":"IRepository Interface"},{"location":"Ethereum%20Distribution%20System/IRepository/#source","text":"Represents a source with version information, a unique identifier, and associated metadata. Input Type Description struct Source { struct LibSemver . Version version ; bytes32 sourceId ; bytes metadata ; }","title":"Source"},{"location":"Ethereum%20Distribution%20System/IRepository/#versiondoesnotexist","text":"Error indicating that the specified version does not exist. error VersionDoesNotExist ( uint256 version ) Input Type Description version uint256 The version number that does not exist.","title":"VersionDoesNotExist"},{"location":"Ethereum%20Distribution%20System/IRepository/#releasezeronotallowed","text":"Error indicating that a release with a zero value is not allowed. error ReleaseZeroNotAllowed ()","title":"ReleaseZeroNotAllowed"},{"location":"Ethereum%20Distribution%20System/IRepository/#versionexists","text":"Error indicating that the specified version already exists. error VersionExists ( uint256 version ) Input Type Description version uint256 The version number that already exists.","title":"VersionExists"},{"location":"Ethereum%20Distribution%20System/IRepository/#versionincrementinvalid","text":"Error indicating that the version increment is invalid. error VersionIncrementInvalid ( uint256 version ) Input Type Description version uint256 The version number that caused the error. Notice The version increment must be exactly one for either major, minor, or patch.","title":"VersionIncrementInvalid"},{"location":"Ethereum%20Distribution%20System/IRepository/#emptyreleasemetadata","text":"error EmptyReleaseMetadata () Notice Error indicating that the release metadata is empty.","title":"EmptyReleaseMetadata"},{"location":"Ethereum%20Distribution%20System/IRepository/#versionadded","text":"Emitted when a new version is added to the repository. event VersionAdded ( uint256 version , bytes32 source , bytes buildMetadata ) Input Type Description version uint256 The version number of the added item. source bytes32 The source identifier of the added item. buildMetadata bytes Additional metadata related to the build.","title":"VersionAdded"},{"location":"Ethereum%20Distribution%20System/IRepository/#releasemetadataupdated","text":"Emitted when the metadata of a release is updated. event ReleaseMetadataUpdated ( uint256 version , bytes releaseMetadata ) Input Type Description version uint256 The version number of the release. releaseMetadata bytes The metadata associated with the release.","title":"ReleaseMetadataUpdated"},{"location":"Ethereum%20Distribution%20System/IRepository/#updatereleasemetadata","text":"Updates the metadata for a specific release version. function updateReleaseMetadata ( struct LibSemver . Version version , bytes releaseMetadata ) external Input Type Description version struct LibSemver.Version The version of the release to update. releaseMetadata bytes The new metadata to associate with the release. Notice It MUST emit ReleaseMetadataUpdated event.","title":"updateReleaseMetadata"},{"location":"Ethereum%20Distribution%20System/IRepository/#repositoryname","text":"Retrieves the name of the repository. function repositoryName () external view returns ( bytes32 ) Output Type Description 0 bytes32 The name of the repository as a bytes32 value.","title":"repositoryName"},{"location":"Ethereum%20Distribution%20System/IRepository/#newrelease","text":"Creates a new release for the given source ID. function newRelease ( bytes32 sourceId , bytes metadata , struct LibSemver . Version version ) external Input Type Description sourceId bytes32 The unique identifier of the source. metadata bytes The metadata associated with the release. version struct LibSemver.Version The semantic version of the new release. Notice It MUST emit VersionAdded event.","title":"newRelease"},{"location":"Ethereum%20Distribution%20System/IRepository/#getlatest","text":"Retrieves the latest source. function getLatest () external view returns ( struct IRepository . Source ) Output Type Description 0 struct IRepository.Source The requested source","title":"getLatest"},{"location":"Ethereum%20Distribution%20System/IRepository/#get","text":"Retrieves a specific item from the repository. function get ( struct LibSemver . Version baseVersion , enum LibSemver . requirements requirement ) external view returns ( struct IRepository . Source ) Input Type Description baseVersion struct LibSemver.Version the base of required version requirement enum LibSemver.requirements the requirement of the version Output 0 struct IRepository.Source The requested Source .","title":"get"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/","text":"# InvalidRepository # error InvalidRepository ( contract IRepository repository ) RepositoryAlreadyExists # error RepositoryAlreadyExists ( contract IRepository repository ) VersionOutdated # error VersionOutdated ( contract IRepository repository , uint256 version ) InvalidInstance # error InvalidInstance ( address instance ) VersionedDistributionAdded # event VersionedDistributionAdded ( contract IRepository repository , uint256 version , enum LibSemver . requirements requirement , address initializer ) VersionChanged # event VersionChanged ( address repository , uint256 oldVersion , uint256 newVersion ) RequirementChanged # event RequirementChanged ( contract IRepository repository , enum LibSemver . requirements oldRequirement , enum LibSemver . requirements newRequirement ) VersionedDistributionRemoved # event VersionedDistributionRemoved ( contract IRepository repository ) Instantiated # event Instantiated ( address repository , bytes argsHash ) addVersionedDistribution # function addVersionedDistribution ( contract IRepository repository , struct LibSemver . Version version , enum LibSemver . requirements requirement , address initializer ) external changeRequirement # function changeRequirement ( contract IRepository repository , struct LibSemver . Version version , enum LibSemver . requirements requirement ) external getVersionedDistributions # function getVersionedDistributions () external view returns ( address [] repositories ) getVersionedDistributionURI # function getVersionedDistributionURI ( contract IRepository repository ) external view returns ( string ) instantiate # function instantiate ( contract IRepository repository , bytes args ) external returns ( address [], bytes32 , uint256 ) removeVersionedDistribution # function removeVersionedDistribution ( contract IRepository repository ) external","title":"IVersionDistributor"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#_1","text":"","title":""},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#invalidrepository","text":"error InvalidRepository ( contract IRepository repository )","title":"InvalidRepository"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#repositoryalreadyexists","text":"error RepositoryAlreadyExists ( contract IRepository repository )","title":"RepositoryAlreadyExists"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#versionoutdated","text":"error VersionOutdated ( contract IRepository repository , uint256 version )","title":"VersionOutdated"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#invalidinstance","text":"error InvalidInstance ( address instance )","title":"InvalidInstance"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#versioneddistributionadded","text":"event VersionedDistributionAdded ( contract IRepository repository , uint256 version , enum LibSemver . requirements requirement , address initializer )","title":"VersionedDistributionAdded"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#versionchanged","text":"event VersionChanged ( address repository , uint256 oldVersion , uint256 newVersion )","title":"VersionChanged"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#requirementchanged","text":"event RequirementChanged ( contract IRepository repository , enum LibSemver . requirements oldRequirement , enum LibSemver . requirements newRequirement )","title":"RequirementChanged"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#versioneddistributionremoved","text":"event VersionedDistributionRemoved ( contract IRepository repository )","title":"VersionedDistributionRemoved"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#instantiated","text":"event Instantiated ( address repository , bytes argsHash )","title":"Instantiated"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#addversioneddistribution","text":"function addVersionedDistribution ( contract IRepository repository , struct LibSemver . Version version , enum LibSemver . requirements requirement , address initializer ) external","title":"addVersionedDistribution"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#changerequirement","text":"function changeRequirement ( contract IRepository repository , struct LibSemver . Version version , enum LibSemver . requirements requirement ) external","title":"changeRequirement"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#getversioneddistributions","text":"function getVersionedDistributions () external view returns ( address [] repositories )","title":"getVersionedDistributions"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#getversioneddistributionuri","text":"function getVersionedDistributionURI ( contract IRepository repository ) external view returns ( string )","title":"getVersionedDistributionURI"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#instantiate","text":"function instantiate ( contract IRepository repository , bytes args ) external returns ( address [], bytes32 , uint256 )","title":"instantiate"},{"location":"Ethereum%20Distribution%20System/IVersionDistributor/#removeversioneddistribution","text":"function removeVersionedDistribution ( contract IRepository repository ) external","title":"removeVersionedDistribution"},{"location":"architecture/","text":"Smart contract infrastructure # The Rankify smart contract infrastructure is built upon a modular design, emphasizing trustless operations to facilitate progressive decentralization within organizations and to mitigate some of the roadblocks on wider adoption of decentralized governance. Adhering to systems theory principles, the architecture can be understood as a black box, responding to stimuli inputs with defined output reactions, while its key feature is the support for recursive patterns, enabling iterative processes on both input and output levels. Including governing body, infrastructure as consisting of two main pieces: App Store : Registry of different ranking system applications that may be installed on cells Cell infrastructures : Dimensions for ranking that participants produce. Note The rankify community governing DAO and multi-sig in the image above can be seen as an instance of Cell infrastructure. Cells # A single cell is an autonomous governance unit, structured as an NxM matrix of inputs and outputs connected to a multisig-wallet. Each cell, representing a specific topic or workgroup, leverages a modular and customizable infrastructure consisting of: Rank NFT : A semi-fungible ERC1155 token signifying the bearer's rank within the subject. Governance Token : An ERC20 token used for governance, minted by exchanging Rank NFTs. DAO contract : OSx DAO Contract governed entirely by holders of the governance token. App Instance : Ranking app, implements the autonomous competence identification protocol. Multisig Wallet : A wallet adhering to the Gnosis ISafe , connecting governing bodies and facilitating decision-making. Protocol is modular, loosely-coupled interfaces oriented and trends to support already existing multi-sig infrastructure, may easily incorporate DAOs built on other frameworks as well as experimentation. Cells may be distinguished in three categories based on origin: Factory deployed, established protocols that adapt technology, and modified experimentation structures, that are referred as Primordial , Generated , and Mutated accordingly. Above diagram describes infrastructure Generated cells adhere, while diagram involving governing body (green blocks) on top of this page describes primordial cell, which yet has no Rank NFT asset to complete it, as well as it is not listed in any auto-generation registries. Ethereum Distribution System # The core concept of scaling Rankify is to give ability for organizations to easily spawn whole pieces of new infrastructure, such as new cells, or new applications that form organizations unique offerings to others in the network. Such spawning should be as easy as possible, yet it should be secure and permission less and scale well. Thus we develop a distribution system with goal to provide as generic and permission less approach as possible with yet a security guarantees between different organizations, that are translated trough curating own application infrastructure. Distribution system infrastructure consist of: IInstallerPlugin : Combines the abilities of ( IInstantiator ) and act as a plugin within the Aragon OSx framework ( Plugin ). IDistributon : Manages and serves information about groups of source code (packages) from version-controlled repositories. It ensures these repositories comply with the IRepository interface. IInstantiator : Creates new instances of contracts using the ISourceController as an authority. It also acts as a registry for active instances and ensures version compatibility with the source controller. IRepository : Defines how source code repositories should be structured. It introduces SourceTypes to accommodate different ways of consuming source code. ISourceController : The authoritative source for managing source code distribution. It works with repositories ( IRepository ) and defines rules for versioning and access. classDiagram class IInstallerPlugin { <<abstract>> } class IInstantiator { <<Interface>> instantiate(repository, args) uint256 instantiateExact(repository, version, args) uint256 instanceCheck(instance) bool instanceVersion(instance) Tag remove(instance) getSourceControl(instance) ISourceController getInstance(instanceId) address[] getInstancesNum() uint256 getActiveInstancesIds() uint256[] } class IDistribution { <<Interface>> getDistributionId() bytes32 getDistribution() Distribution } class IRepository { <<Interface>> updateReleaseMetadata(release, releaseMetadata) createVersion(release, source, buildMetadata, releaseMetadata) buildCount(release) uint256 getVersion(tagHash) Version getVersion(tag) Version getLatestVersion(source) Version getLatestVersion(release) Version latestRelease() uint8 } class ISourceController { <<Interface>> getDistributors() address[] isDistributor(distributor) bool setVersionRequirement(repository, versionRequired) getVersionRequired(repository) VersionRequirement addDistributor(repository, versionRequired) removeDistributor(repository) addBatchDistributors(repositories, requirements) removeBatchDistributors(repositories) setBatchVersionRequirements(repositories, requirements) } class VersionRequirement { <<Interface>> baseVersion Tag requirementType VersionRequirementTypes } class Tag { <<struct>> release uint8 build uint16 } class VersionRequirementTypes { <<enumeration>> All MajorVersion ExactVersion } IInstallerPlugin --|> IInstantiator : implements IInstallerPlugin --|> OSx_Plugin : implements IInstantiator --> ISourceController : uses IInstantiator --> IRepository : uses ISourceController --> IRepository : uses ISourceController --> IDistribution : uses ISourceController --> VersionRequirement : uses VersionRequirement --> Tag VersionRequirement --> VersionRequirementTypes IRepository ..> IDistribution: instantiates App developer either deploys plain source or sets up a repository for his work and deploys his source to that to provide version control interface. Then he can propose any organization to add his repository to their Installer Plugin to have his application available for installation. If it succeeds, organization members now can create their own instances of applications that will share same source code, version requirements and permissions to proxy calls on to the DAO contract. 6c9438dd-597a-47a0-88c3-eb1ebf749764 Anyone may create own repository and become distributor. Rankify DAO will curate its own distribution contract, listing its own resources and community-approved third-party applications. IVRepoFactory is provided for convenience of creating new repositories. Repositories # The App Repositories are built upon the IRepository interface, which mirrors the functionality of the OSx IPluginRepo . It provides a versioned repository for source non-permissive control implementations. Users of that repository can be sure that every time they request specific application version, same address will be returned and keep track of newest releases. Note Source code that is being versioned does not need to be aware of the repository structure, already existing contracts may be added to the repository. Installer # Installer is an abstract integration contract that takes distributions and installs them into target organization. It must implement IInstaller interface, and it's only interface dependency is Repository contract. It is an abstract that must be extended to meet specific target interface requirements. Note Application might have time-zone specific properties, making it necessary to have multiple instances of the same application, each with its own unique configuration. Warning Installer main use case assumes ability to instantiate multiple instances, it does not track permissions to install applications nor it enforces their count. Such limits can be introduced in the instantiation logic InstallationPlan requirements that are approved by DAO. OSx Installer # A concrete installer version, \"OSx Installer\" plugin is provided to support integration with Aragon OSx framework. This Installer must be authorized by the DAO, maintains a list of approved distributors as well it is the only system component that must be aware of installation target specific interfaces. It simplifies the process for users to launch whitelisted applications, acting as a proxy between instances and the DAO contract as well as generalizes apps development.","title":"Smart contract infrastructure"},{"location":"architecture/#smart-contract-infrastructure","text":"The Rankify smart contract infrastructure is built upon a modular design, emphasizing trustless operations to facilitate progressive decentralization within organizations and to mitigate some of the roadblocks on wider adoption of decentralized governance. Adhering to systems theory principles, the architecture can be understood as a black box, responding to stimuli inputs with defined output reactions, while its key feature is the support for recursive patterns, enabling iterative processes on both input and output levels. Including governing body, infrastructure as consisting of two main pieces: App Store : Registry of different ranking system applications that may be installed on cells Cell infrastructures : Dimensions for ranking that participants produce. Note The rankify community governing DAO and multi-sig in the image above can be seen as an instance of Cell infrastructure.","title":"Smart contract infrastructure"},{"location":"architecture/#cells","text":"A single cell is an autonomous governance unit, structured as an NxM matrix of inputs and outputs connected to a multisig-wallet. Each cell, representing a specific topic or workgroup, leverages a modular and customizable infrastructure consisting of: Rank NFT : A semi-fungible ERC1155 token signifying the bearer's rank within the subject. Governance Token : An ERC20 token used for governance, minted by exchanging Rank NFTs. DAO contract : OSx DAO Contract governed entirely by holders of the governance token. App Instance : Ranking app, implements the autonomous competence identification protocol. Multisig Wallet : A wallet adhering to the Gnosis ISafe , connecting governing bodies and facilitating decision-making. Protocol is modular, loosely-coupled interfaces oriented and trends to support already existing multi-sig infrastructure, may easily incorporate DAOs built on other frameworks as well as experimentation. Cells may be distinguished in three categories based on origin: Factory deployed, established protocols that adapt technology, and modified experimentation structures, that are referred as Primordial , Generated , and Mutated accordingly. Above diagram describes infrastructure Generated cells adhere, while diagram involving governing body (green blocks) on top of this page describes primordial cell, which yet has no Rank NFT asset to complete it, as well as it is not listed in any auto-generation registries.","title":"Cells"},{"location":"architecture/#ethereum-distribution-system","text":"The core concept of scaling Rankify is to give ability for organizations to easily spawn whole pieces of new infrastructure, such as new cells, or new applications that form organizations unique offerings to others in the network. Such spawning should be as easy as possible, yet it should be secure and permission less and scale well. Thus we develop a distribution system with goal to provide as generic and permission less approach as possible with yet a security guarantees between different organizations, that are translated trough curating own application infrastructure. Distribution system infrastructure consist of: IInstallerPlugin : Combines the abilities of ( IInstantiator ) and act as a plugin within the Aragon OSx framework ( Plugin ). IDistributon : Manages and serves information about groups of source code (packages) from version-controlled repositories. It ensures these repositories comply with the IRepository interface. IInstantiator : Creates new instances of contracts using the ISourceController as an authority. It also acts as a registry for active instances and ensures version compatibility with the source controller. IRepository : Defines how source code repositories should be structured. It introduces SourceTypes to accommodate different ways of consuming source code. ISourceController : The authoritative source for managing source code distribution. It works with repositories ( IRepository ) and defines rules for versioning and access. classDiagram class IInstallerPlugin { <<abstract>> } class IInstantiator { <<Interface>> instantiate(repository, args) uint256 instantiateExact(repository, version, args) uint256 instanceCheck(instance) bool instanceVersion(instance) Tag remove(instance) getSourceControl(instance) ISourceController getInstance(instanceId) address[] getInstancesNum() uint256 getActiveInstancesIds() uint256[] } class IDistribution { <<Interface>> getDistributionId() bytes32 getDistribution() Distribution } class IRepository { <<Interface>> updateReleaseMetadata(release, releaseMetadata) createVersion(release, source, buildMetadata, releaseMetadata) buildCount(release) uint256 getVersion(tagHash) Version getVersion(tag) Version getLatestVersion(source) Version getLatestVersion(release) Version latestRelease() uint8 } class ISourceController { <<Interface>> getDistributors() address[] isDistributor(distributor) bool setVersionRequirement(repository, versionRequired) getVersionRequired(repository) VersionRequirement addDistributor(repository, versionRequired) removeDistributor(repository) addBatchDistributors(repositories, requirements) removeBatchDistributors(repositories) setBatchVersionRequirements(repositories, requirements) } class VersionRequirement { <<Interface>> baseVersion Tag requirementType VersionRequirementTypes } class Tag { <<struct>> release uint8 build uint16 } class VersionRequirementTypes { <<enumeration>> All MajorVersion ExactVersion } IInstallerPlugin --|> IInstantiator : implements IInstallerPlugin --|> OSx_Plugin : implements IInstantiator --> ISourceController : uses IInstantiator --> IRepository : uses ISourceController --> IRepository : uses ISourceController --> IDistribution : uses ISourceController --> VersionRequirement : uses VersionRequirement --> Tag VersionRequirement --> VersionRequirementTypes IRepository ..> IDistribution: instantiates App developer either deploys plain source or sets up a repository for his work and deploys his source to that to provide version control interface. Then he can propose any organization to add his repository to their Installer Plugin to have his application available for installation. If it succeeds, organization members now can create their own instances of applications that will share same source code, version requirements and permissions to proxy calls on to the DAO contract. 6c9438dd-597a-47a0-88c3-eb1ebf749764 Anyone may create own repository and become distributor. Rankify DAO will curate its own distribution contract, listing its own resources and community-approved third-party applications. IVRepoFactory is provided for convenience of creating new repositories.","title":"Ethereum Distribution System"},{"location":"architecture/#repositories","text":"The App Repositories are built upon the IRepository interface, which mirrors the functionality of the OSx IPluginRepo . It provides a versioned repository for source non-permissive control implementations. Users of that repository can be sure that every time they request specific application version, same address will be returned and keep track of newest releases. Note Source code that is being versioned does not need to be aware of the repository structure, already existing contracts may be added to the repository.","title":"Repositories"},{"location":"architecture/#installer","text":"Installer is an abstract integration contract that takes distributions and installs them into target organization. It must implement IInstaller interface, and it's only interface dependency is Repository contract. It is an abstract that must be extended to meet specific target interface requirements. Note Application might have time-zone specific properties, making it necessary to have multiple instances of the same application, each with its own unique configuration. Warning Installer main use case assumes ability to instantiate multiple instances, it does not track permissions to install applications nor it enforces their count. Such limits can be introduced in the instantiation logic InstallationPlan requirements that are approved by DAO.","title":"Installer"},{"location":"architecture/#osx-installer","text":"A concrete installer version, \"OSx Installer\" plugin is provided to support integration with Aragon OSx framework. This Installer must be authorized by the DAO, maintains a list of approved distributors as well it is the only system component that must be aware of installation target specific interfaces. It simplifies the process for users to launch whitelisted applications, acting as a proxy between instances and the DAO contract as well as generalizes apps development.","title":"OSx Installer"},{"location":"architecture/applications/","text":"Applications # Overview # While application distribution system can, and is encouraged, to be used for pretty much anything, Rankify main goal is to provide necessary infrastructure for Autonomous Competence identification (ACID) protocol installation. In our implementation the asset is being decoupled from governing body to allow for more flexible and dynamic governance and to encourage experimentation without sacrificing for governance security. The representation of comptence is done via Rank NFTs . Hence it is required that applications are able to mint and burn Rank NFTs assets, they can do this by using installation proxy as their mint and burn target. When called, the proxy will mint or burn the asset on behalf of the application. This approach allows applications to be versioned, prevents outdated instances from being used. Tip You are welcome to write your own application, if it meets community standards, it can be included in the Rankify ecosystem, or used to create your own DAO ecosystem autonomously! Best list challenge # The best list challenge is a simple example of an application that can be built on top of the Rankify infrastructure. It allows users to submit their ideas and vote on them to create a ranked list of ideas. Protocol is designed in accordance to autonomous competence identification protocol: participation is anonymous, time continuous and results are verifiable.","title":"Applications"},{"location":"architecture/applications/#applications","text":"","title":"Applications"},{"location":"architecture/applications/#overview","text":"While application distribution system can, and is encouraged, to be used for pretty much anything, Rankify main goal is to provide necessary infrastructure for Autonomous Competence identification (ACID) protocol installation. In our implementation the asset is being decoupled from governing body to allow for more flexible and dynamic governance and to encourage experimentation without sacrificing for governance security. The representation of comptence is done via Rank NFTs . Hence it is required that applications are able to mint and burn Rank NFTs assets, they can do this by using installation proxy as their mint and burn target. When called, the proxy will mint or burn the asset on behalf of the application. This approach allows applications to be versioned, prevents outdated instances from being used. Tip You are welcome to write your own application, if it meets community standards, it can be included in the Rankify ecosystem, or used to create your own DAO ecosystem autonomously!","title":"Overview"},{"location":"architecture/applications/#best-list-challenge","text":"The best list challenge is a simple example of an application that can be built on top of the Rankify infrastructure. It allows users to submit their ideas and vote on them to create a ranked list of ideas. Protocol is designed in accordance to autonomous competence identification protocol: participation is anonymous, time continuous and results are verifiable.","title":"Best list challenge"},{"location":"architecture/specifications/","text":"Specifications [DRAFT] # Warning These specs are still in active development, and are subject to change. This document outlines the detailed specifications for our project. Each section in this document corresponds to a different component of the system and is further divided into two categories: Functional Requirements and Security Requirements. Functional Requirements : define the functionality that a system or system component must be able to perform. They describe what the system should do and include specifications for features, capabilities, and operational constraints. Security Requirements : define the measures that are needed to protect the system from potential threats. They often involve access control, data protection, and system integrity. Security requirements are given per implementation given the context of the implementations as these requirements are not universal. Functional requirements # Distribution system # Repositories # Functional interface requirements are described in IRepository , functionality must fulfill following unit tests: It emits VersionCreated when createVersion is called successfully It reverts with EmptyReleaseMetadata if no metadata is supplied in createVersion It reverts with ReleaseZeroNotAllowed if a release number is set to zero in createVersion When no release nor version exists: It reverts with VersionHashDoesNotExist if getVersion is called It reverts with ReleaseDoesNotExist if updateReleaseMetadata is called It returns zero if latestRelease is called on repository with no releases It returns zero if buildCount is called on repository with no releases It reverts with VersionHashDoesNotExist if called getLatestVersion(address) It reverts with ReleaseDoesNotExist if called getLatestVersion(uint8) When version and release exists: It reverts with InvalidReleaseIncrement if a release number is incremented by more than one It reverts with EmptyReleaseMetadata if no metadata is supplied in updateReleaseMetadata It reverts with AlreadyInPreviousRelease if createVersion if the same source address It emits VersionCreated when createVersion is called with valid major version increment It emits VersionCreated when createVersion is called with valid minor version increment It returns correct count for given major version upon calling buildCount It returns correct Version if getVersion is called with valid major and minor version It returns correct Version if getVersion is called with valid tagHash It returns correct Version if getLatestVersion(address) is called It returns correct Version if getLatestVersion(uint8) is called It emits ReleaseMetadataUpdated when updateReleaseMetadata is called successfully It returns correct release count if latestRelease is called Registry [TBD] # Cells [TBD] # Rank NFT # Must implement OpenSea compatible uri format that can resolve to title, Description and image Must allow only owner to modify metadata May implement additional IRankToken interface Governance Token [TBD] # Applications # There is no strict interface requirements on the applications, they can generally stay unaware of any of the infrastructure components. However, it must implement the following functional requirements: It shall be able to to mint and/or burn at least one Rank NFT asset. Asset minting shall involve participation costs Participation costs shall be immutable parameter paid in ERC20 token Participation payment token must differ from governance token of target organization Participation cost relation to minted asset must be possible to express in formally verifiable way Optional requirements # These formally are not required, but will speed up process of incorporating application in the protocol supporting user interfaces. It shall implement application initialization schema It shall implement instance initialization schema It may implement IRankifyInstanceCommons Instantiator # installer must implement IInstantiator interface, functionality must fulfill following unit tests: it emits RepositoryAdded if addRepository is called successfully. it emits Instantiated if instantiate is called successfully. it reverts with NotDistributing if instantiate is called with non-existing repository. it reverts with VersionOutOfBounds if instantiate version does not match. it emits Repositor Removed when removeRepository` is called successfully. it emits Instantiated if instantiateLatest is called successfully. it reverts with RepositoryDoesNotExist if instantiateLatest is called with non-existing repository. when repository already exists: it emits DistributionChanged if upgradeDistribution is called successfully with already existing repository. when DistributionChanged was emitted: it reverts with VersionOutOfBounds upon calling installation methods with outdated version. it reverts with VersionDeprecated upon outdated version instance attempting to call installation target. it emits Upgraded if upgrade is called successfully. it reverts with VersionOutOfBounds if upgrade is called with version that does not match the required version. It returns correct Repository if getRepository is called with valid instance address It returns all instances of a repository if getInstances is called with valid repository address It returns all active repositories if getRepositories is called It returns version tag if getVersion is called with valid instance address It returns VersionRequirement if getVersionRequirement is called with valid instance address It reverts with InstanceDoesNotExist if getVersionRequirement is called with non-existing instance address It reverts with InstanceDoesNotExist if getVersion is called with non-existing instance address It reverts with NotDistributing if getRepository is called with non-existing instance address It reverts with NotDistributing if getInstances is called with non-existing repository address Instance [TBD] # Security requirements # Security specifications outlined per contract instance are implementation agnostic. They are meant to be implemented in a way that is most suitable for the given context. Following definitions extend ERC-2119 definitions: Access point : A function or method that is part of the protected contract's interface. WHITELIST : Set of addresses that are explicitly allowed on certain access points. BLACKLIST : Set addresses that are explicitly disallowed on certain access points. RESTRICTED : An access point that MUST enforce WHITELIST. UNRESTRICTED : An access point that MAY enforce BLACKLIST. DAO Owned Repository # DAO controlled functional Repository must fulfill following security requirements: All non-read methods are RESTRICTED, where only WHITELIST member is Rankify Multisig Rankify Multisig MAY assign WHITELIST members to each access point individually Rankify Multisig MAY revoke WHITELIST members from each access point individually All read methods are UNRESTRICTED, with no BLACKLIST members No one may modify security settings except Rankify Multisig Rankify Multisig MAY transfer it's privileges to another account Rankify Multisig # Multisig controlled functional Safe Wallet Initially deployed with a single signer and 1-of-1, Rankify DAO signer Rankify DAO signer MAY add or remove signers Rankify DAO signer MAY change the threshold Rankify DAO signer MAY revoke it's own signer status App Instances #","title":"Specifications [DRAFT]"},{"location":"architecture/specifications/#specifications-draft","text":"Warning These specs are still in active development, and are subject to change. This document outlines the detailed specifications for our project. Each section in this document corresponds to a different component of the system and is further divided into two categories: Functional Requirements and Security Requirements. Functional Requirements : define the functionality that a system or system component must be able to perform. They describe what the system should do and include specifications for features, capabilities, and operational constraints. Security Requirements : define the measures that are needed to protect the system from potential threats. They often involve access control, data protection, and system integrity. Security requirements are given per implementation given the context of the implementations as these requirements are not universal.","title":"Specifications [DRAFT]"},{"location":"architecture/specifications/#functional-requirements","text":"","title":"Functional requirements"},{"location":"architecture/specifications/#distribution-system","text":"","title":"Distribution system"},{"location":"architecture/specifications/#repositories","text":"Functional interface requirements are described in IRepository , functionality must fulfill following unit tests: It emits VersionCreated when createVersion is called successfully It reverts with EmptyReleaseMetadata if no metadata is supplied in createVersion It reverts with ReleaseZeroNotAllowed if a release number is set to zero in createVersion When no release nor version exists: It reverts with VersionHashDoesNotExist if getVersion is called It reverts with ReleaseDoesNotExist if updateReleaseMetadata is called It returns zero if latestRelease is called on repository with no releases It returns zero if buildCount is called on repository with no releases It reverts with VersionHashDoesNotExist if called getLatestVersion(address) It reverts with ReleaseDoesNotExist if called getLatestVersion(uint8) When version and release exists: It reverts with InvalidReleaseIncrement if a release number is incremented by more than one It reverts with EmptyReleaseMetadata if no metadata is supplied in updateReleaseMetadata It reverts with AlreadyInPreviousRelease if createVersion if the same source address It emits VersionCreated when createVersion is called with valid major version increment It emits VersionCreated when createVersion is called with valid minor version increment It returns correct count for given major version upon calling buildCount It returns correct Version if getVersion is called with valid major and minor version It returns correct Version if getVersion is called with valid tagHash It returns correct Version if getLatestVersion(address) is called It returns correct Version if getLatestVersion(uint8) is called It emits ReleaseMetadataUpdated when updateReleaseMetadata is called successfully It returns correct release count if latestRelease is called","title":"Repositories"},{"location":"architecture/specifications/#registry-tbd","text":"","title":"Registry [TBD]"},{"location":"architecture/specifications/#cells-tbd","text":"","title":"Cells [TBD]"},{"location":"architecture/specifications/#rank-nft","text":"Must implement OpenSea compatible uri format that can resolve to title, Description and image Must allow only owner to modify metadata May implement additional IRankToken interface","title":"Rank NFT"},{"location":"architecture/specifications/#governance-token-tbd","text":"","title":"Governance Token [TBD]"},{"location":"architecture/specifications/#applications","text":"There is no strict interface requirements on the applications, they can generally stay unaware of any of the infrastructure components. However, it must implement the following functional requirements: It shall be able to to mint and/or burn at least one Rank NFT asset. Asset minting shall involve participation costs Participation costs shall be immutable parameter paid in ERC20 token Participation payment token must differ from governance token of target organization Participation cost relation to minted asset must be possible to express in formally verifiable way","title":"Applications"},{"location":"architecture/specifications/#optional-requirements","text":"These formally are not required, but will speed up process of incorporating application in the protocol supporting user interfaces. It shall implement application initialization schema It shall implement instance initialization schema It may implement IRankifyInstanceCommons","title":"Optional requirements"},{"location":"architecture/specifications/#instantiator","text":"installer must implement IInstantiator interface, functionality must fulfill following unit tests: it emits RepositoryAdded if addRepository is called successfully. it emits Instantiated if instantiate is called successfully. it reverts with NotDistributing if instantiate is called with non-existing repository. it reverts with VersionOutOfBounds if instantiate version does not match. it emits Repositor Removed when removeRepository` is called successfully. it emits Instantiated if instantiateLatest is called successfully. it reverts with RepositoryDoesNotExist if instantiateLatest is called with non-existing repository. when repository already exists: it emits DistributionChanged if upgradeDistribution is called successfully with already existing repository. when DistributionChanged was emitted: it reverts with VersionOutOfBounds upon calling installation methods with outdated version. it reverts with VersionDeprecated upon outdated version instance attempting to call installation target. it emits Upgraded if upgrade is called successfully. it reverts with VersionOutOfBounds if upgrade is called with version that does not match the required version. It returns correct Repository if getRepository is called with valid instance address It returns all instances of a repository if getInstances is called with valid repository address It returns all active repositories if getRepositories is called It returns version tag if getVersion is called with valid instance address It returns VersionRequirement if getVersionRequirement is called with valid instance address It reverts with InstanceDoesNotExist if getVersionRequirement is called with non-existing instance address It reverts with InstanceDoesNotExist if getVersion is called with non-existing instance address It reverts with NotDistributing if getRepository is called with non-existing instance address It reverts with NotDistributing if getInstances is called with non-existing repository address","title":"Instantiator"},{"location":"architecture/specifications/#instance-tbd","text":"","title":"Instance [TBD]"},{"location":"architecture/specifications/#security-requirements","text":"Security specifications outlined per contract instance are implementation agnostic. They are meant to be implemented in a way that is most suitable for the given context. Following definitions extend ERC-2119 definitions: Access point : A function or method that is part of the protected contract's interface. WHITELIST : Set of addresses that are explicitly allowed on certain access points. BLACKLIST : Set addresses that are explicitly disallowed on certain access points. RESTRICTED : An access point that MUST enforce WHITELIST. UNRESTRICTED : An access point that MAY enforce BLACKLIST.","title":"Security requirements"},{"location":"architecture/specifications/#dao-owned-repository","text":"DAO controlled functional Repository must fulfill following security requirements: All non-read methods are RESTRICTED, where only WHITELIST member is Rankify Multisig Rankify Multisig MAY assign WHITELIST members to each access point individually Rankify Multisig MAY revoke WHITELIST members from each access point individually All read methods are UNRESTRICTED, with no BLACKLIST members No one may modify security settings except Rankify Multisig Rankify Multisig MAY transfer it's privileges to another account","title":"DAO Owned Repository"},{"location":"architecture/specifications/#rankify-multisig","text":"Multisig controlled functional Safe Wallet Initially deployed with a single signer and 1-of-1, Rankify DAO signer Rankify DAO signer MAY add or remove signers Rankify DAO signer MAY change the threshold Rankify DAO signer MAY revoke it's own signer status","title":"Rankify Multisig"},{"location":"architecture/specifications/#app-instances","text":"","title":"App Instances"},{"location":"support/","text":"Community channels # Discord Telegram Twitter","title":"Community channels"},{"location":"support/#community-channels","text":"Discord Telegram Twitter","title":"Community channels"},{"location":"support/faq/","text":"Frequently asked questions #","title":"Frequently asked questions"},{"location":"support/faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"}]}